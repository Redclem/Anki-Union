#separator:tab
#html:false
#notetype column:1
#deck column:2
Basique Maths	L3::Théorie de la programmation::Introduction	Définitions inductives d'ensembles	Définition d'un type ensemble qui peut se référer à lui même, e.g;.: - Unitaire : \( X = 1 \)  - Naturel : \( X = X + 1 \)  - Nlist : \( 1 + nat \times X\)
Basique Maths	L3::Théorie de la programmation::Introduction	Relation	Une relation est un sous-ensemble d'un produit cartésien
Basique Maths	L3::Théorie de la programmation::Introduction	Cas particuliers de relations	- Unitaire : prédicat - Binaire : notation infixe \( xRy \) signifie \( (x,y) \in R\).
Basique Maths	L3::Théorie de la programmation::Introduction	Définition inductive de relation	Définition d'une relation par des règles d'inférence.
Basique Maths	L3::Théorie de la programmation::Introduction	Règles d'inférence pour \(le\)	 \( \frac{}{le(n,n)}A \) et \( \frac{le(n,k)}{le(n,S(k))}R\)
Basique Maths	L3::Théorie de la programmation::Introduction	Vocabulaire des règles d'inférences	Dans \( \frac{le(n,k)}{le(n,S(k))}R \) , \( le(n,k) \) est une prémice, \( le(n,S(k)) \) la conclusion, et \( n,k \) sont des métavariables (quantifiées universellement).
Basique Maths	L3::Théorie de la programmation::Introduction	Dérivation / Preuve	On appelle dérivation ou preuve un arbre construit à l'aide des règles d'inférence avec des axiomes aux feuilles.
Basique Maths	L3::Théorie de la programmation::Introduction	Convention de définition de la relation avec les règles d'inférences	La relation \( R \) est l'ensemble des couples \( A = (a_1, \dots, a_n) \) tels qu'il existe une dérivation avec \( A \in R\) à la racine.
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Expressions arithmétiques	L'ensemble \( AE \) des expressions arithmétiques est défini par la grammaire suivante:  \( A ::= \underline k |a_1 \oplus a_2 \) , où \( k\in \Z \) et \( a_1, a_2 \) des expressions arithmétiques. Plus formellement, \( \underline k = Const(k) \) et \( a_1\oplus a_2 = Add(a_1, a_2)\).
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Sémantique opérationnelle à grands pas	"C'est la relation inductive notée \(reval\) ou \(\Downarrow\) (""L'expression s'évalue en"") par:  \( A\frac{}{reval(\underline k, k)} \) et \( R\frac{reval(a_1,k_1)\quad reval(a_2, k_2)}{reval(a_1\oplus a_2, k)}k = k_1 + k_2 \)  où \( k = k_1 + k_2\) est une condition d'application."
Basique Maths	L3::Théorie de la programmation::Introduction	Preuves par induction sur un type	En général, pour les définitions inductives d'ensembles:  \( \text {type } t = | C_i\text{ of } u_i^1 \times \dots \times u_i^{n_i} \) , avec \( u_i^j \) un type préexsitant ou \( t \) ; Pour montrer \( \forall x \in t, P(x) \) , il suffit de montrer \( k \) propriétés: la \( i \) -ème propriété à montrer s'écrit: - Si \( P(x_j) \) est vraie pour tous les \( j \) tels que \( u_i^j = t \) , alors \( P(C_i(x_1, \dots ,x_{n_i}))\).
Basique Maths	L3::Théorie de la programmation::Introduction	Preuve par induction sur une relation	Pour prouver \( \forall x \in t, x \in R \implies P(x) \) , Il suffit de montrer une propriété pour chaque règle d'inférence: - Si pour tout \( x_i \in R \) dans les prémices, \( P(x_i) \) , alors \( P(x_c) \) où \( x_c \) est tel que la conclusion est \( x_c \in R\)
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Ordre partiel	Un ordre partiel sur un ensemble est une relation binaire réflexive, transitive et antisymétrique.
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Minorant / Majorant	Un minorant de  \( A \subseteq (E, \le) \)  est un  \( m \in E \)  tel que  \( \forall x \in A, m \le x \) . Définition analogue du majorant avec  \( m \ge x\).
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Plus grand minorant / majorant	Un plus grand minorant de  \( A \subseteq (E, \le) \)  est un élément de  \( E \)  noté  \( \sqcap A \)  tel que c'est un minorant de  \( A \) , et pour tout minorant  \( m \)  de  \( A \) ,  \( m \le\sqcap A \) . Le plus grand majorant est noté  \( \sqcup A\) et est défini de manière analogue.
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Treillis complet	Un treillis complet est un ensemble muni d'un ordre partiel tel que pour tout  \( A \subseteq (E, \le) \) ,  \( \sqcap A, \sqcup A\) existent.
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Théorème de Knaster-Tarski	Toute fonction  \( f \) croissante d'un treillis complet dans lui-même admet un plus petit et plus grand point fixe (Le sous-ensemble des points fixes est un treillis complet), et le plus petit point fixe est le plus petit prépoint fixe
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Application du théorème K-T	On voit les règles d'inférences comme des fonctions  \( f_i \)  qui a un ensemble de couples associe l'ensemble des nouveaux couples construits, et on considère  \( f \)  l'union de ces fonctions. Alors la relation est définie comme le plus petit point fixe de  \( f\).
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Preuve par induction sur une relation avec K-T	"Montrer, avec une propriété  \( P \)  ,  \( \forall x \in t, x \in R \implies P(x) \)  par induction revient à montrer que pour toute fonction  \( f_i \)  associée à une règle de dérivation, pour tout ensemble  \( A \)  d'éléments,  \( P(A) \implies P(f_i(A))\) (i.e. la propriété ""passe en dérivant"")."
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Définitions en pratique	En pratique, on définit: - Les types par leurs constructeurs - Les relations par des règles d'inférence - Les fonctions par récursion Soit en Coq / Ocaml, soit avec des phrases.
Basique Maths	L3::Théorie de la programmation::Théorème de Knaster-Tarski	Preuves en pratique	En pratique, on rédige toujours les preuves. On n'utilise pas d'objets non construits explicitement dans une preuve.
Basique Maths	L3::Théorie de la programmation::Relations binaires	Clotûre réflexive, transitive, ...	Les clotûres réflexive, transitive, transitive et réflexive, symétrique d'une relation  \( R \)  sont les plus petites relations respectivement réflexive, transitive, transitive et réflexive, symétrique contenant  \( R \) . On note  \( R^=, R^+, R^* \)  respectivement les clotûres réflexive, transitive, transitive et réflexive de  \( R\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Divergence	Soit  \( (E, \rightarrow) \)  une relation binaire sur  \( E \) . Une divergence issue de  \( x_0 \)  est une suite  \( (x_i)_{i \in \N} \)  telle que  \( \forall i \in \N, x_i \rightarrow x_{i + 1}\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Relation binaire divergente	La relation  \( \rightarrow \)  diverge si et seulement si il existe une divergence issue d'un  \( x \in E \) . Sinon, on dit que  \( \rightarrow\) termine ou est terminante.
Basique Maths	L3::Théorie de la programmation::Relations binaires	Principe d'induction bien fondée	Le principe d'induction bien fondée (PIBF) est la propriété sur une relation  \( \rightarrow \) : Pour tout prédicat  \( P \)  sur  \( E \) , si:  \( \forall x \in E,(\forall y \in E, x \rightarrow y \implies P(y)) \implies P(x) \)  (en particulier, si  \( x \not \rightarrow \) ,  alors  \( P(x) \) ) alors  \( \forall x \in E, P(x)\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Théorème d'induction bien fondée	Une relation  \( (E, \rightarrow)\) binaire est terminante si et seulement si elle vérifie le principe d'induction bien fondée.
Basique Maths	L3::Théorie de la programmation::Introduction	Méthode pour une preuve par induction dans une copie	- Énoncer la propriété qu'on montre - Énoncer la structure ou relation sur laquelle on fait l'induction - Énoncer les cas possibles - Pour chaque cas : Énoncer les hypothèses d'induction et la propriété à démontrer.
Basique Maths	L3::Théorie de la programmation::Relations binaires	Relation fonctionnelle ou déterministe	On dit que  \( R \subseteq E \times F \)  est fonctionnelle ou déterministe si  \( \forall x \in E, y,x \in F, (xRy \wedge x Rz) \implies y = z\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Relation fonctionelle totale	Une relation fonctionelle  \( R \subseteq E \times F \)  est totale si  \( \forall x \in E, \exists y \in F, xRy\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Notation \(\upharpoonright\)	On note  \( R \upharpoonright A = \{(x,y) \in R | x \in A\}\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Relation fonctionelle associée à une fonction	\( R \subseteq E \times F \)  associée à  \( f : E \to F \)  est la relation fonctionnelle telle que  \( \forall x \in E, \)   \( xR(f(x))\).
Basique Maths	L3::Théorie de la programmation::Relations binaires	Théorème de récursion bien fondée	Soit  \( (a, >) \)  terminante. Pour  \( a \in A \) , on note  \( Pred(a) = \{a' \in A | a > a'\} \) . On se donne une fonction  \( F \)  telle que pour tout  \( a \in A, h : Pred(a) \to B \) ,  \( F(a,h)\in B \) . Alors il existe une unique  \( f : A \to B \)  telle que  \( \forall a \in A, f(a) = F(a, f\upharpoonright(Pred(a))) \) . ( \( f\upharpoonright(Pred(a) \)  correspond grossièrement à  \( f \)  restreinte à  \( Pred(a)\). )
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Sémantique opérationnelle à petit pas	C'est la relation inductive, notée \(\rightarrow \subset AE \times AE\) définie par: \(A\frac{}{\underline {k_1} \oplus \underline{k_2} \rightarrow \underline k}k = k_1 + k_2\), \(R_{pg}\frac{a_1 \rightarrow a'_1}{a_1\oplus a_2 \rightarrow a_1' \oplus a_2}\), \(R_{pd}\frac{a_1 \rightarrow a'_1}{\underline k \oplus a_1 \rightarrow \underline k \oplus a'_1} \) Ce sont des règles contextuelles : il y a les spectateurs \(a_2 \) et \(\underline k\).
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Relation entre les sémantiques opérationnelles	Les sémantiques opérationnelles sont équivalentes: \(\forall a \in AE, k \in \Z, a\Downarrow k \Leftrightarrow a \rightarrow^*\underline k\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Ensemble des termes	Avec: - \(\Sigma\) un ensemble fini de constantes, où chaque constante a une arité dans \(\N\), notées \(f, g ,a ,b\). - \(V\) un ensemble infini de variables / d'inconnues notées \(X, Y, Z\) ou \(x,y,z\). L'ensemble \(T(\Sigma, V)\) des termes sur \(\Sigma\) et \(V\) est défini de manière inductive par \(t ::= f^k(t_1, \dots, t_k) | X\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Ensemble des variables	On définit par induction sur \(t \in T(\Sigma, V)\) l'ensemble \(Vars(t)\) des variables. 2 familles de cas: - \(Vars(X) = \{X\}\) - \(Vars(f(t_1, \dots ,t_k)) = \bigcup\limits_{i = 1}^k Vars(t_i)\)
Basique Maths	L3::Théorie de la programmation::Termes et unification	Substitution	Une substitution (sur \(\Sigma, V\)) notée \(\sigma, \sigma', \sigma_1\) est une fonction partielle à domaine de définition fini de \(V\) dans \(T(\Sigma, V)\). On représente \(\sigma\) par un ensemble fini de couples \((X, t)\) tels que si \((X,t), (X,t') \in \sigma, t = t'\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Domaine d'une substitution	Le domaine \(dom(\sigma)\) d'une substitution \(\sigma\) est son ensemble de définition, i.e. \(dom(\sigma) = \{X \in V|\exists t, (X,t) \in \sigma\}\)
Basique Maths	L3::Théorie de la programmation::Termes et unification	Application d'une substitution	Le résultat de l'application de \(\sigma\) à \(t \in T(\Sigma, V)\) noté \(\sigma(t)\) est défini par induction sur \(t\) : 2 familles de cas: - \(\sigma(f(t_1, \dots, t_k)) = f(\sigma(t_1), \dots, \sigma(t_k))\) - \(\sigma(X) = X\) si \(X \notin dom(\sigma)\) - \(\sigma(X) = \sigma(X)\) si \(X \in dom(\sigma)\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Notation substitution / application	On définit une substitution par les couples comme \(\sigma = [\frac {t_1}{X_1}, \dots, \frac {t_n}{X_n}]\) et \(t[\frac {t_1}{X_1}, \dots, \frac {t_n}{X_n}] = \sigma(t)\) avec la substitution précédemment définie.
Basique Maths	L3::Théorie de la programmation::Termes et unification	Problème d'unification	Un problème d'unification est un ensemble de paires de termes dans \(T(\Sigma, V)\) appelées équations: \(\mathcal P= \{\{t_1, u_1\}, \dots, \{t_k, v_k\}\}\), noté \( \mathcal P = \{t_1 =^?u_1,\dots, t_k =^?u_k\} \).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Unificateur	Un unificateur d'un problème d'unification \(\mathcal P\) est une substitution \(\sigma\) telle que \(\forall t=^?u \in \mathcal P, \sigma(t) = \sigma(u)\). On note \(U(\mathcal P)\) l'ensemble des unificateurs de \(\mathcal P\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Substitution en tant que problème d'unification	Une substitution \(\sigma = \{(X_i, t_i)\}\) peut être vue comme le problème d'unification correspondant \(\mathcal P = \{X_i=^?t_i\}\). On notera simplement \(\sigma\) ce problème.
Basique Maths	L3::Théorie de la programmation::Termes et unification	Lemme sur l'unification	Pour \(\sigma\) une substitution, \(\forall \sigma' \in U(\sigma) , \sigma'\circ \sigma =\sigma'\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	État dans l'algorithme d'unification	Un état est soit un couple \((\mathcal P, \sigma)\) soit l'état d'échec \(\bot\). Un état \((\varnothing, \sigma)\) est un état de réussite.
Basique Maths	L3::Théorie de la programmation::Termes et unification	Algorithme de substitution	L'algorithme de substitution correspond à une relation notée \(\to\) définie par: \(\bot \not \to\), \((\varnothing, \sigma) \not \to\) - 5 cas pour un état \((\{t=^?t'\}\uplus\mathcal P,\sigma)\): - \((\{f(t_1, \dots, f_k)=^?f(u_1, \dots, u_k)\}\uplus\mathcal P,\sigma) \to (\{t_1 =^? u_1, \dots, t_k =^? u_k\} \uplus \mathcal P, \sigma)\) - \((\{f(t_1, \dots, f_k)=^?g(u_1, \dots, u_k)\}\uplus\mathcal P,\sigma) \to \bot\) si \(f \neq g\) - \((\{X =^? t\}\uplus\mathcal P,\sigma) \to (\mathcal P[\frac tX], [\frac tX] \circ \sigma)\) si \(X \notin Vars(t)\) - \((\{X =^? t\}\uplus\mathcal P,\sigma) \to \bot\) si \(X \in Vars(t)\) et \(t \neq X\) - \((\{X =^? X\}\uplus\mathcal P,\sigma) \to (\mathcal P, \sigma)\)
Basique Maths	L3::Théorie de la programmation::Termes et unification	Unificateur le plus général	Un unificateur le plus général de \(\mathcal P\) est un \(\sigma \in  U(\mathcal P)\) tel que \(\forall \sigma' \in U(\mathcal P), \exists \sigma'', \sigma' = \sigma'' \circ \sigma\).
Basique Maths	L3::Théorie de la programmation::Termes et unification	Propriété de l'algorithme d'unification	L'algorithme d'unification calcule un unificateur le plus général si et seulement si le problème initial avait une solution.
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Déterminisme de \(\Downarrow\) et \(\to\)	Les relations \(\Downarrow\) et \(\to \) sont déterministes.
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Expressions arithmétiques avec déclarations locales (LAE)	C'est l'ensemble des expressions définies par la grammaire: \(a ::= \underline k | a_1 \oplus a_2 | \text{let } x := a_1 \text{ in } a_2 |x\), où \(x\) est un identificateur de variable quelconque.
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Substitution dans les LAE	On définit par induction sur \(a \in LAE\) le résultat de la substitution des occurences libres de \(x\) dans \(a\) par \(\underline k\), noté \(a[\frac{\underline k}x]\): - \(\underline k'[\frac{\underline k}x] = \underline k'\) - \(y[\frac{\underline k}x] = \begin{array}{ll} y \text { si } y \ne x \\ \underline k \text { sinon}\end{array}\) - \((a_1 \oplus a_2)[\frac{\underline k}x] = a_1[\frac{\underline k}x]\oplus a_2[\frac{\underline k}x]\) - \((\text{let }y = a_1 \text{ in }a_2)[\frac{\underline k}x] = \begin{array}{ll} \text{let }y = a_1[\frac{\underline k}x] \text{ in }a_2[\frac{\underline k}x]) \text { si } y \ne x \\ \text{let }y = a_1[\frac{\underline k}x] \text{ in }a_2) \text { sinon}\end{array}\)
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Règle supplémentaire de grands pas pour les LAE	\(\frac{a_1 \Downarrow k_1 \quad a_2[\frac{\underline k_1}x] \Downarrow k_2}{\tlet x = a_1 \tin a_2 \Downarrow k_2}\)
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Règles supplémentaires de petits pas pour les LAE	\(\frac{a_1 \to a'_1}{\tlet x = a_1 \tin a_2 \to \tlet x = a'_1 \tin a_2}\) et \(\frac{}{\tlet x = \underline k \tin a_1 \to a_1[\frac{\underline k}x]}\)
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Ensemble des LAE closes	On note \(LAE_0\) l'ensemble des LAE closes, i.e. sans variables libres.
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Lemme sur les petits pas sur les LAE	Si \(a \in LAE_0\) et \(a \to a'\), alors \(a' \in LAE_0\)
Basique Maths	L3::Théorie de la programmation::Expressions arithmétiques	Propriétés de \(\Downarrow\) et \(\to \) sur \(LAE_0\)	\(\Downarrow\) et \(\to\) sont déterministes, totales et équivalentes.
Basic	L3::Théorie de la programmation::Expressions arithmétiques	Autres variantes des AE	- AE avec environnement : l'environnement est une association variable : valeur - AE avec erreurs à l'exécution : Une AE peut s'évaluer en une erreur (i.e. lors d'une division par 0)
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	\(\alpha\)-conversion	"On note \(e =_\alpha e'\) si \(e'\) s'obtient à partir de \(e\) en renommant des variables liées ""sans conflit""."
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	\(\alpha\)-conversion et variables libres	Si \(e =_\alpha e'\), alors \(Vl(e) = Vl(e')\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Langage FUN	C'est le langage correspondant à la grammaire: \(e ::= \underline k | e_1 \oplus e_2 | \text{fun }x\to e|x|e_1 \space e_2\)
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Valeurs dans le langage FUN	Les valeurs correspondent à la grammaire: \(v ::= \underline k | \fun x \to e\)
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Lieur et variable liée	\(\fun x \to e\) est un lieur, \(x\) est liée dans \(e\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Définition des types	Les types sont donnés par la grammaire \(\tau ::= int | \tau_1 \to \tau_2\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Hypothèse de typage	Une hypothèse de typage est un couple \((x,\tau)\) noté \(x:\tau\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Conditions sur les hypothèses de typage pour typer une expression	Si \(\Gamma \vdash e:\tau\) alors \(Vl(e) \subseteq dom(\Gamma)\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Lemme de progrès	Si \(\varnothing \vdash e: int\) et \(e \not \to\) alors \(e = \underline k\). Si \(\varnothing \vdash e : \tau_1 \to \tau_2\) et \(e\not \to\) alors \(e = \fun x \to e'\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Corollaire du lemme de progrès	Si \(\varnothing \vdash e : \tau\), alors soit \(e\) est une valeur, soit \(\exists e', e \to e'\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Renforcement et affaiblissement du typage	- Si \(\Gamma, x:\tau_0 \vdash e:\tau\) et \(x \notin Vl(e)\), alors \(\Gamma \vdash e:\tau\) - Si \(\Gamma \vdash e : \tau\), pour \(x\notin dom(\Gamma)\), \(\Gamma, x:\tau_0 \vdash e:\tau\)
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Préservation du typage	Si \(\varnothing\vdash e : \tau \) et \(e \to e'\), alors \(\varnothing \vdash e':\tau\).
Basique Maths	L3::Théorie de la programmation::Langage Fonctionnel	Étapes de l'inférence de types	- Poser une inconnue de type par sous-expression, ou presque - Construire des contraintes de typage entre les inconnues de type - Résoudre (Unification)
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Système de réécritrue abstraite	Un SRA (système de réécriture abstraite) est une relation binaire sur un ensemble.
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Propriété du diamant	Soit \((A, \to)\) un SRA. \(\to \) satisfait la propriété du diamant ssi: \(\forall(t, u_1,u_2), t\to u_1 \wedge t \to u_2 \implies \exists t', u_1 \to t' \wedge u_2 \to t'\).
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Confluence en un élément	Soit \((A, \to)\) un SRA. \(\to\) est confluente en \(t \in A\) ssi: \(\forall(u_1,u_2), t\to^* u_1 \wedge t \to^* u_2 \implies \exists t', u_1 \to^* t' \wedge u_2 \to^* t'\)
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Confluence	Soit \((A, \to)\) un SRA. \(\to \) est confluente si et seulement si elle est confluente en tout \(t\in A\).
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Propriété de Church-Rosser	\((A, \to)\) a la propriété de Church-Rosser si et seulement si: \(\forall (t_1, t_2) \in A^2, t_1 \leftrightarrow^*t_2 \implies \exists t' \in A, t_1 \to^* t' \wedge t_2 \to^* t'\) où \(\leftarrow = (\to)^{-1} = \{(y,x) \in A^2 |x \to y\} \) et \(\leftrightarrow = \leftarrow \cup \to\) et \(\leftrightarrow^* = (\leftrightarrow)^*\)
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Théorème associé à la propriété de Church-Rosser	\((A, \to)\) satisfait la propriété de Church-Rosser si et seulement si \(\to \) est confluente.
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Confluence locale	\(_\to \)est localement confluente ssi: \(\forall (t, u_1, u_2) \in A^3, t \to u_1\wedge t\to u_2 \implies \exists t' \in A, u_1 \to^* t' \wedge u_2 \to^* t' \)
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Lemme de Neumann	Si \(\to \) est localement confluente et terminante, alors elle est confluente.
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Théorème du plongement / mesurer	Soit \((B, >)\) un SRA terminant et \((A, \to)\) un SRA. S'il existe \(\phi : A \to B\) tel que \(a \to a' \implies \phi(a) \to \phi(a')\) alors \(\to\) termine
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Produit lexicographique	\((A, \to_A)\) et \((B, \to_B)\) SRA. Un produit lexicographique de \((A,\to_A)\) et \((B, \to_B)\) est le SRA noté \((A\times B, \to _{A\times B}\) défini par: \((a,b) \to_{A \times B}(a',b')\) si et seulement si \(a\to_A a'\) ou \(a = a'\) et \(b\to_Bb'\).
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Terminaison du produit lexicographique	Si \(\to_A, \to_B\) terminent, alors \(\to_{A \times B}\) termine.
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Multiensemble	Un multiensemble sur \(A\) est donné par une fonction \(M : A \to \N\) (multiplicité). On note \(M\) le multiensemble correspondant.
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Multiensemble fini	\(M: A \to \N\) est fini si \(M(a) \ne 0\) pour un nombre fini de \(a \in A\).
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Taille d'un multiensemble	La taille \(|M| \) de \(M\) est \(|M| = \sum\limits_{ a \in A}M(a)\).
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Opérations sur les multiensembles	- On note \(M_1 \le M_2\) si \(\forall a \in A, M_1(a) \le M_2(a)\) - \(M_1 \cup M_2 = M_1 + M_2\) - \(M_1 - M_2 = M_1 \ominus M_2\) où \(n \ominus k = \begin{array}{ll} n - k \text{ si } n \ge k \\ 0 \text { sinon}\end{array}\)
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Extension multiensemble	Pour \((A, >)\) SRA, l'extension mutliensemble de \((A,>)\) notée \(>_ {mul}\) est une relation sur les multiensembles finis sur \(A\) définie par \(M >_{mul} N\) ssi: \(\exists X, Y \) multiensembles sur \(A\) tels que: - \(\varnothing \ne X \le M\) - \(N = (M - X) \cup Y\) - \(\forall y \in Y, \exists x \in X, x > y\).
Basique Maths	L3::Théorie de la programmation::Éléments de réécriture	Terminaison de l'extension multiensemble	Avec \((A, >)\) SRA, \(>\) termine si et seulement si \(>_{mul}\) termine.
Basique Maths	L3::Théorie de la programmation::Systèmes de réécriture de mots	Système de réécriture de mots	Un système de réécriture de mots (SRM) sur \(\Sigma\) est donné par un ensemble \(R \subseteq(\Sigma^*)^2\) de couples de mots sur \(\Sigma\) : \(R = \{ (l,r);l,r \in \Sigma^*\}\)
Basique Maths	L3::Théorie de la programmation::Systèmes de réécriture de mots	Relation binaire d'un SRM	Un SRM \(R\) définit une relation binaire sur \(\Sigma^*\) notée \(\to_R\) ou \(\to\) définie par: \(u \to v\) ssi \(\exists x,y\in \Sigma ^*, \exists (l,r) \in R, u = xly \wedge v = xry\).
Basique Maths	L3::Théorie de la programmation::Systèmes de réécriture de mots	Paire critique	\((r_1w_1, zr_2w_2)\) est une paire critique de \(R\) si il existe \((l_1, r_1,),(l_2, r_2) \in R\) tels que - \(l_1w_1=zl_2w_2\) - \(\varepsilon \in \{w_1, w_2\}\)
Basique Maths	L3::Théorie de la programmation::Systèmes de réécriture de mots	Paire joignable	Une paire critique \(\{u, u'\}\) est joignable si \(\exists w'',w \to^*w'\wedge w\to w''\)
Basique Maths	L3::Théorie de la programmation::Systèmes de réécriture de mots	Confluence / critiques / joignables	\(R\) est localement confluent si et seulement si toutes ses paires critiques sont joignables.
Basique Maths	L3::Théorie de la programmation::Domaine et points fixes	Ordre partiel complet	Un ordre partiel \((E, \sqsubseteq)\) est complet si pour toute chaîne infinie (\((e_i)_{i \in \N}\) telle que \(\forall i \in \N, e_i \sqsubseteq e_{i + 1}\)), il existe un plus petit majorant des \((e_i)\) noté \(\bigsqcup\limits_{ i \in \N}e_i\).
Basique Maths	L3::Théorie de la programmation::Domaine et points fixes	Domaine	Un domaine est un ordre partiel complet qui admet un plus petit élément \(\bot\).
