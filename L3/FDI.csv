#separator:tab
#html:false
#notetype column:1
#deck column:2
Basique	L3::FDI::Automates finis et langages rationnels	Définition AFD / NFA	AFD : Automate fini déterministe, n'a pas de blocage. NFA : Automate fini non déterministe, avec blocage et \(\varepsilon\)-transition.
Basique	L3::FDI::Automates finis et langages rationnels	Stabilité des langages rationnels	les langages rationnels sont stables par union, concaténation, complémentaire, intersection.
Basique	L3::FDI::Automates finis et langages rationnels	Équivalence NFA / DFA	Les deux reconnaissent les langages rationnels.
Basique	L3::FDI::Automates finis et langages rationnels	GNFA	Automate non déterministe généralisé (transitions étiquetées par expression régulières)
Basique Maths	L3::FDI::Automates finis et langages rationnels	Lemme de pompage	Soit \( L \in Rat(\Sigma) \) . Alors il existe un entier \( n \in \mathbb N^* \) , appelé longueur de pompage, tel que pour tout mot \( u \in L \) tel que \( |u| \ge n \) admet une décomposition de la forme \( xyz \) telle que: - \( y \ne \varepsilon \)  - \( |xy| \le n \)  - \( \forall k \in \mathbb N, xy^kz \in L\)
Basique Maths	L3::FDI::Automates finis et langages rationnels	Mots indistinguables	Pour \( L \in \Sigma^* \) , \( x,y \in \Sigma^* \) sont indistinguables ssi \( \forall z \in \Sigma^*, xz \in L \Leftrightarrow yz \in L \) . On note \( \equiv_L\)la relation d'équivalence obtenue.
Basique Maths	L3::FDI::Automates finis et langages rationnels	Indice d'un langage	L'indice de \( L \) est le nombre de classes d'équivalences de \( \Sigma^* \) pour \( \equiv_L\).
Basique Maths	L3::FDI::Automates finis et langages rationnels	Théorème de Myhill-Nerode	Un langage \( L \) est rationnel ssi l'indice de \( L \) est fini et dans ce cas, l'indice de \( L \) est égal au nombre d'états du plus petit DFA reconnaissant \( L\).
Basique Maths	L3::FDI::Automates finis et langages rationnels	Nom du théorème de minimisation	Myhill-Nerode.
Basique Maths	L3::FDI::Automates finis et langages rationnels	Résiduel	Pour tout mot \( x \in \Sigma^* \) et langage \( L \) , le résiduel de \( x \) est \( x^{-1}L = \{z \in\Sigma^*, xz \in L\}\)
Basique Maths	L3::FDI::Automates finis et langages rationnels	Automate minimal à partir des classes d'équivalence	On peut construire un automate minimal pour un langage rationnel où chaque état correspond à une classe de \( \equiv_L\). Dans ce cas les classes correspondent aux mots dont le calcul finit dans un même état.
Basique Maths	L3::FDI::Langages récursivement énumérables	Énumérateur	"Un énumérateur \(E\) est une machine à 2 rubans : rubans de travail et de sortie. - Sur le ruban de sortie, \(E\) écrit les mots du langage énuméré séparés par \(\# \notin \Sigma\). - La tête sur le ruban de sortie va vers la droite quand elle écrit un caractère et reste immobile sinon."
Basique Maths	L3::FDI::Langages récursivement énumérables	Langage récursivement énumérable	Un langage est récursivement énumérable si et seulement si il est énuméré par un certain énumérateur.
Basique Maths	L3::FDI::Langages récursivement énumérables	Caractérisation des langages récursivement énumérables	Un langage est récursivement énumérable si et seulement si il est reconaissable (par machine de Turing).
Basique Maths	L3::FDI::Langages récursivement énumérables	Machine de Turing universelle	Notée \(\sqcup\), c'est une machine de Turing qui prend en entrée un couple \(\langle M, w\rangle\) où \(M\) est une machine de Turing et \(w\) est une entrée de \(M\). Le calcul de \(\sqcup\) sur \(\langle M, w \rangle\): - Accepte si \(M\) accepte \(w\) - Rejette si \(M\) rejette \(w\) - Sinon, ne termine pas
Basique Maths	L3::FDI::Langages récursivement énumérables	Langage reconnu par \(\sqcup\), reconnaissabilité	\(\sqcup\) reconnaît \(A = \{\langle M, x\rangle | M \text{ reconnaît }x\}\) \(A\) est reconnaissable par définition.
Basique Maths	L3::FDI::Langages récursivement énumérables	Théorème de l'arrêt	Le langage \(A\) reconnu par \(\sqcup\) est indécidable.
Basique Maths	L3::FDI::Langages récursivement énumérables	Problèmes du tout et du rien	Il s'agit d'étudier les langages: \(V_{CFG}\): ensemble des CFG reconnaissant le langage vide \(T_{CFG}\): ensemble des CFG reconnaissant \(\Sigma^*\).
Basique Maths	L3::FDI::Langages récursivement énumérables	Décidabilité du rien	\(V_{CFG}\) est décidable.
Basique Maths	L3::FDI::Langages récursivement énumérables	Décidabilité du tout	\(T_{CFG}\) est indécidable.
Basique Maths	L3::FDI::Automates finis et langages rationnels	Calcul des classes d'équivalence d'états	Pour calculer \(\equiv\) définie par \(q \equiv q' \Leftrightarrow \forall u \in \Sigma^*, (\delta(q,u) \in F \Leftrightarrow \delta(q',u) \in F) \), on calcule les \(\equiv_i\) se restreignant au mots de longueur au plus \(i\) par récurrence: - \(q \equiv_0 q'\) si \(q,q'\) sont tous deux dans ou en dehors de \(F\) - \(q \equiv_{i + 1} q'\) si et seulement si \( \forall a \in \Sigma, \delta(q, a) \equiv_i\delta(q',a)\) et \(q\equiv_iq'\). On calcule les \(\equiv_i\) jusqu'à stabilisation, on a alors \(\equiv\).
Basique Maths	L3::FDI::Automates finis et langages rationnels	Décidabilité des théories logiques	\(Th(\N, + ,=)\) est décidable (Théorie des entiers avec addition et égalité. L'arithmétique du premier ordre n'est pas décidable.
Basique Maths	L3::FDI::Automates finis et langages rationnels	Langage des entiers satisfaisant une formule	Le langage des codes des entiers satisfaisant une formule de \(Th(\N, +, =)\) est un langage rationnel.
Basique Maths	L3::FDI::Automates finis et langages rationnels	Caractérisation de la vérité d'un énoncé par le langage reconnu	Un énoncé est vrai si l'automate correspondant accepte le mot vide.
Basique Maths	L3::FDI::Langages algébriques	Langage algébrique	Défini comme en prépa.
Basique Maths	L3::FDI::Langages algébriques	Langage d'une grammaire	Le langage d'une grammaire est \(\{w \in \Sigma^* | S \Rightarrow^*w\}\).
Basique Maths	L3::FDI::Langages algébriques	Grammaire ambigüe	Une grammaire est ambigüe s'il existe 2 arbres de dérivation distincts d'un même mot.
Basique Maths	L3::FDI::Langages algébriques	Dérivation canonique	La dérivation canonique est la dérivation la plus à gauche.
Basique Maths	L3::FDI::Langages algébriques	Caractérisation de l'ambiguité	Une grammaire est ambigüe si et seulement si il existe un mot qui admet 2 dérivations le plus à gauche différentes.
Basique Maths	L3::FDI::Langages algébriques	Langage intrinsèquement ambigu	Un langage est intrinsèqueemnt ambigu si toute grammaire l'engendrant est ambigüe.
Basique Maths	L3::FDI::Langages algébriques	Langages rationnels et algébriques	Les langages rationnels sont algébriques.
Basique Maths	L3::FDI::Langages algébriques	Forme normale de Chomsky	Une grammaire est sous forme normale de Chomsky (FNC) si ses règles sont de la forme: - \(S \to \varepsilon\) - \(A \to BC, B, C \ne S\) - \(A \to a\)
Basique Maths	L3::FDI::Langages algébriques	Langages engendrés par des FNC	Tout langage algébrique est engendré par une grammaire en FNC.
Basique Maths	L3::FDI::Langages algébriques	Difficulté de la reconnaissance d'un langage algébrique	Tout langage algébrique est reconnaissable en temps polynomial.
Basique Maths	L3::FDI::Langages algébriques	Algorithme CYK	Algorithme de programmation dynamique pour reconnaître une grammaire en FNC: Pour vérifier si \(w = w_1 \dots w_n\) dans la grammaire, on remplit les cases d'une matrice \(n\times n\): la case \(i,j\) contient les lettres engendrant \(w_i\dots w_j\). On accepte si \(S\) est dans la case \(1,n\).
Basique Maths	L3::FDI::Langages algébriques	Complexité de CYK	CYK est en complexité \(\mathcal O(n^3)\).
Basique Maths	L3::FDI::Langages algébriques	Lemme de l'étoile algébrique	Pour \(A\) algébrique, il existe \(p \in \N\) la longueur de pompage telle que pour \(s \in A\) de longueur au moins \(p\), \(s = uvxyz\) tel que: - \(\forall i \in \N, uv^ixy^iz \in A\) - \(|vy| > 0\) - \(|vxy| \le p\)
Basic	L3::FDI::Langages algébriques	Automate à pile	Un automate à pile est défini formellement par un 6-uplet \((Q, \Sigma, P, \delta, Q_0, F)\): - Un ensemble d'états \(Q\) - Un alphabet d'entrée \(\Sigma\) - Un alphabet de pile \(P\) - Une fonction de transfert de \(Q \times \Sigma_\varepsilon \times P_\varepsilon\) dans \(\mathcal P(Q \times P_\varepsilon)\) (non déterminisme autorisé). - Un ensemble d'états initiaux \(Q_0 \in Q\) - Un ensemble \(F \subseteq Q\) d'états finaux
Basic	L3::FDI::Langages algébriques	Langages reconnus par automate à pile	Les automates à pile reconnaissent exactement les langages algébriques.
Basic	L3::FDI::Machines de Turing et Décidabilité	Machine de Turing	Une machine de Turing est définie formellement par un 7-uplet \((Q, \Sigma, \Gamma, \delta, q_0, q_a, q_r)\): - \(Q\) l'ensemble des états - \(\Sigma\) l'alphabet d'entrée - \(\Gamma\) l'alphabet de ruban - \(\delta : Q \times \Gamma \to Q \times \Gamma \times\{G,D\}\) (on peut parfois ajouter l'option de la tête immobile - \(q_0\) l'état initial - \(q_a\) l'état acceptant - \(q_r\) l'état de rejet
Basic	L3::FDI::Machines de Turing et Décidabilité	Fonctionnement de la machine de Turing	- Le ruban contient initialement l'entrée sur les premières cases et des blancs au-delà - On calcule en appliquant la fonction de transition. La tête reste immobile si elle est tout à gauche et qu'elle va à gauche  - La machine s'arrête si elle entre dans \(q_a\) ou \(q_r\) en acceptant ou refusant respectivement.
Basic	L3::FDI::Machines de Turing et Décidabilité	Représentation de l'état d'une machine de Turing	L'état d'une machine de Turing est représenté par l'état interne, l'état du ruban et la position de la tête. On représente ceci par le mot infini \(uqvB^\infty\), avec \(q\) l'état interne et \(uvB^\infty\) l'état du ruban avec la tête sur la première lettre de \(v\).
Basic	L3::FDI::Machines de Turing et Décidabilité	Langage accepté	Le langage accepté par une machine de Turing \(M\) est l'ensemble des mots \(w \in \Sigma^*\) tels que \(M\) entre dans l'état \(q_a\) pendant le calcul sur l'entrée \(w\).
Basic	L3::FDI::Machines de Turing et Décidabilité	Langage reconnaissable / décidable	\(L\) est reconnaissable si c'est le langage accepté par une machine \(M\). \(L\) est décidable s'il existe une machine \(M\) qui accepte \(L\) et rejette \(\bar L\).
Basic	L3::FDI::Machines de Turing et Décidabilité	Lien langage décidable et reconnaissable	Un langage décidable est reconnaissable.
Basic	L3::FDI::Machines de Turing et Décidabilité	Variantes de machines de Turing	- Machine à plusieurs rubans - Machine non déterministe Ces deux variantes sont équivalentes aux machines de Turing simples.
Basique Maths	L3::FDI::Machines de Turing et Décidabilité	Problème du tout pour les machines de Turing, décidabilité	Le problème du tout pour les machines de Turing correspond au langage: \(Tout_{MT} = \{\langle M \rangle, L(M) = \Sigma^*\}\). Ce problème est indécidable.
Basique Maths	L3::FDI::Machines de Turing et Décidabilité	Historique de calcul	L'historique du calcul acceptant de \(M\) sur l'entrée \(w\) est une suite de configurations \(C_1, \dots, C_n\) de \(M\) telles que - \(C_1\) est la configuration initiale de \(M\) sur l'entrée \(w\) - \(C_n\) est une configuration acceptante - \(C_{i + 1}\) est la configuration qui suit immédiatement \(C_i\) dans un calcul de \(M\), pour tout \(1 \le i < n\).
Basique Maths	L3::FDI::Machines de Turing et Décidabilité	Théorème de récursion	Pour \(T\) machine de Turing calculant une fonction partielle \(t : \Sigma^* \times \Sigma^* \to \Sigma^*\), Il existe une machine de Turing \(R\) calculant une fonction partielle \(r : \Sigma^*\to \Sigma^*\) telle que pour tout mot \(u \in \Sigma^*, r(w) = t(\langle R \rangle, w)\).
Basique Maths	L3::FDI::Machines de Turing et Décidabilité	Problème du tout pour les automates à piles et les grammaires	\(T_{CFG}\) et \(T_{PDA}\)(arrêt pour les automates à pile) sont équivalents.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Fonctions de base	- Fonction constante : \(\begin{array}{ll} \N \to \N \\ x \mapsto 0\end{array}\) - Fonction successeur : \(\begin{array}{ll} \N \to \N \\ x \mapsto x+1\end{array}\) - Projection : \(pr_p^i:\begin{array}{ll} \N^p \to \N \\ (x_1, \dots, x_p) \mapsto x_i\end{array}\)
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Schéma de composition	À partir de fonctions \(g_1, \dots, g_p : \N^n \to \N\) et de la fonction \(f: \N^p \to \N\), on construit la fonction composée \(h : \N^n \to \N\) : \(h(g_1(x_1, \dots, x_n), \dots, g_p(x_1, \dots, x_n))\)
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Schéma de récurrence positive	A partir de \(g : \N^p \to \N\) et de \(h : \N^{p + 2} \to \N\), on construit \(f : \N^{p + 1} \to \N\) par: - \(f(x_1,\dots, x_p, 0) = g(x_1, \dots, x_p)\) - \(f(x_1, \dots, x_p, y+1) = h(x_1, \dots, x_p, y, f(x_1,\dots, x_p, y))\)
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Fonctions récursives primitves	L'ensemble des fonctions récursives primitves est le plus petit ensemble de fonctions contenant les fonctions de base et clos pour les schémas de composition et de récurrence primitive.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Exemples de fonctions récursives primitives	- Les constantes non nulles - Les opérations arithmétiques: addition, soustraction, multiplication, exponentiation, quotient et reste.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Fonctions primitives récursives et machines de Turing	- Les fonctions récursives primitves sont calculables par machine de Turing. - Il existe des fonctions calculables par machine de Turing qui ne sont pas récursives primitives.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Schéma de minimisation	Soit \(g  : \N ^{p + 1} \to \N\) partielle. Alors le schéma de minimisation sur \(g\) donne \(f:\N^p \to \N\) partielle définie par: \(f(x_1, \dots, x_p) = \min\{z | g(x_1, \dots, x_p, z) = 0\}\) ou \(\bot\) si l'ensemble est vide.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Fonctions \(\mu\)-récursives	L'ensemble des fonctions \(\mu\)-récursives est le plus petit ensemble de fonctions partielles contenant les fonctions de base et clos par les schémas de composition, de récurrence primitive et de minimisation.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Fonctions \(\mu\)-récursives et machine de Turing	Une fonction partielle \(f : \N \to \N\) est calculable par machine de Turing si et seulement si elle est \(\mu\)-récursive.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Forme normale d'une fonction \(\mu\)-récursive, existence	Une forme normale d'une fonction \(\mu\)-récursive est sa forme où le schéma de récurrence est utilisé au plus 1 fois. Toute fonction \(\mu\)-récursive admet une forme normale.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Caractérisation des fonctions récursives primitives par le temps de calcul	Une fonction est primitive récursive si elle est totale, calculable par machine de turing, et son temps de calcul sur une entrée est primitif récursif.
Basique Maths	L3::FDI::Fonctions primitives récursives et µ-récursives	Temps de calcul astronomique	Le temps de calcul d'une fonction calculable non primitive récursive est dit astronomique.
Basique Maths	L3::FDI::Lambda-Calcul	\(\lambda\)-terme	Un \(\lambda\)-terme est défini par induction: - Les variables sont des \(\lambda\)-termes - Si \(u,v\) sont des \(\lambda\)-termes, \((u v)\) (application de \(u \) à \(v\) est un \(\lambda\)-terme - Si \(x\) est une variable et \(t\) est un terme, \(\lambda x. t\) est un \(\lambda\)-terme
Basique Maths	L3::FDI::Lambda-Calcul	Notation pour plusieurs applications	On note \(uvw = (uv)w\).
Basique Maths	L3::FDI::Lambda-Calcul	Entiers de Church	On représente les entiers par les termes: \(\bar 0 = \lambda f \lambda x . x\), \(f\mapsto Id = f^0\) \(\bar 1 = \lambda f .\lambda x. fx\), \(f \mapsto f\) \(\bar n = \lambda f .\lambda x.f^nx\), \(f \mapsto f^n\).
Basique Maths	L3::FDI::Lambda-Calcul	Renommage des variables libres	On peut renommer les variables libres dans un terme. Cela définit une relation d'équivalence entre termes notée \(t \equiv_\alpha t'\).
Basique Maths	L3::FDI::Lambda-Calcul	Substitution	La substitution de \(t\) à \(x\) dans \(u\), notée \(u[\frac tx]\) est obtenue de manière suivante: - Renommer les variables liées de \(u\) pour obtenir un terme \(u'\) tel qu'aucune variable liée de \(u'\) n'est libre dans \(t\). - Remplacer chaque occurence libre de \(x\) dans \(u'\) par \(t\).
Basique Maths	L3::FDI::Lambda-Calcul	\(\beta\)-réduction	Étant donné un \(\lambda\)-terme \(v\), on choisit un sous-terme de la forme \(((\lambda x .u)t)\), auquel on applique l'opération de substitution. On note \(v \to_\beta v'\) si \(v'\) peut s'obtenir à partir de \(v\) par une suite de telles substitutions. One note \(v \to v'\) si \(v'\) peut s'obtenir à partir de \(v\) par une suite finie d'\(\alpha\) et \(\beta\)-réductions.
Basique Maths	L3::FDI::Lambda-Calcul	Propriété de Church-Rosser en lambda-calcul	Si \(v \to v_1\) et \(v \to v_2\), alors il existe \(v'\) tel que: \(v_1 \to v'\) et \(v_2 \to v'\).
Basique Maths	L3::FDI::Lambda-Calcul	Terme normal, unicité	Un terme normal est un terme qui ne peut être \(\beta\)-réduit. Si un terme admet une forme normale, elle est unique à \(\alpha\)-équivalence près.
Basique Maths	L3::FDI::Lambda-Calcul	Obtention d'une forme normale	Si une forme normale existe, on peut l'obtenir par \(\beta\)-réduction le plus à gauche.
Basique Maths	L3::FDI::Lambda-Calcul	Représentation des fonctions primitives récursives	Pour toute fonction primitive récursive \(f : \N^n \to \N\), il existe un \(\lambda\)-terme \(F\) tel que pour tout \((a_1, \dots, a_n) \in \N^n\), \(F \bar a_1\dots \bar a_n\) a pour forme normale \(\overline{f(a_1, \dots, a_n)}\).
Basique Maths	L3::FDI::Lambda-Calcul	Représentation des fonctions \(\mu\)-récursives	Pour toute fonction partielle \(\mu\)-récursive \(f : \N^n \to \N\), il existe un \(\lambda\)-terme \(F\) tel que pour tout \((a_1, \dots, a_n) \in \N^n\) - si \(f(a_1, \dots, a_n)\) est définie, \(F \bar a_1 \dots \bar a_n\) a pour forme normale \(\overline {f(a_1, \dots, a_n)}\).  - si \(f(a_1, \dots, a_n)\) n'est pas définie, \(F \bar a_1 \dots \bar a_n\) n'est pas normalisable.
Basique Maths	L3::FDI::Lambda-Calcul	Constructeur de point fixe	Un constructeur de point fixe est un terme clos \(M\) tel que pour tout terme \(F\), \((M F ) = F ( M F)\).
Basique Maths	L3::FDI::Lambda-Calcul	Combinateur de Curry	Le combinateur de Curry \(Y = \lambda f .(\lambda x.f(x x))(\lambda x.f(xx))\) est un combinateur de point fixe.
Basique Maths	L3::FDI::P et NP	Langage \(P\)	Un langage \(A \subseteq \Sigma^*\) est dans la classe \(P\) s'il existe une machine de Turing déterministe qui le reconnaît en temps polynomial, c'est à dire que pour tout \(x \in \Sigma^*\), - \(M\) accepte \(x\) si et seulement si \(x \in A\)  - \(M\) s'arrête en temps \(\mathcal O(n^k)\) sur toute entrée de taille \(n\), avec la constante indépendante de \(x\).
Basique Maths	L3::FDI::P et NP	Fonction calculable en temps polynomial	Une fonction \(f : \Sigma^* \to \Sigma^*\) est calculable en temps polynomial si elle est calculable par une machine de Turing déterministe en temps polynomial.
Basique Maths	L3::FDI::P et NP	Composition de fonctions calculables en temps polynomial	La composition de fonctions calculables en temps polynomial est calculable en temps polynomial.
Basique Maths	L3::FDI::P et NP	Définition de \(NP\) par certificats	\(A \subseteq \Sigma^*\) est dans \(NP\) si et seulement si il existe \(B \in P\) et un polynome \(p(n)\) tel que pour tout \(x \in \Sigma^n\): \(x \in A\iff\exists y \in \Sigma^{\le p(n)}, \langle x,y\rangle \in B\). \(y\) est le certificat.
Basique Maths	L3::FDI::P et NP	Réduction polynomiale	Soient \(A, B \subseteq \Sigma^*\) deux problèmes. \(A\) se réduit à \(B\) en temps polynomial s'il existe \(f : \Sigma^* \to \Sigma^*\) calculable en temps polynomial telle que: \(\forall x \in \Sigma^*, x \in A \iff f(x) \in B\).
Basique Maths	L3::FDI::P et NP	Problème \(NP\)-complet	Un problème est \(NP\)-complet si il est \(NP\) et tout problème \(NP\) se réduit à lui.
Basique Maths	L3::FDI::P et NP	Problèmes \(NP\)-complets et \(P\)	Soit \(A\) \(NP\)-complet. Alors \(A \in P\) si et seulement si \(P = NP\).
Basique Maths	L3::FDI::P et NP	Relation \(P, NP\)	\(P\subseteq NP\)
Basique Maths	L3::FDI::P et NP	Problème \(NP\) se réduisant à un \(NP\)-complet	Si un problème est \(NP\) et se réduit à un problème \(NP\)-complet, alors il est \(NP\)-complet.
Basique Maths	L3::FDI::P et NP	Circuit booléen	Un circuit booléen est un DAG dont les sommets sont de degré entrant: - 0 pour les constantes et les variables - 1 pour un sommet \(\neg\) - 2 pour les sommets \(\wedge\) et \(\vee\) Avec une unique porte de degré sortant 0 : la porte de sortie.
Basique Maths	L3::FDI::P et NP	Valeur d'une porte, valeur d'un circuit	La valeur d'une porte est la valeur de l'opération booléenne étant donnée la valeur de ses entrées. La valeur d'un circuit est la valeur de la porte de sortie.
Basique Maths	L3::FDI::P et NP	Calcul de la valeur d'un circuit	La valeur \(Val(C)\) d'un circuit se calcule en temps polynomial étant donnés \(C\) et l'entrée \(\alpha\).
Basique Maths	L3::FDI::P et NP	Problème reconnaissable par machine de Turing et circuits booléens	Si \(A \subseteq \{0, 1\}^*\) peut être résolu en temps \(t(n)\) sur des entrées de taille \(n\) par une machine de Turing, alors \(A\) est reconnu par une famille \((c_n)\) de circuits de taille \(\mathcal O(t(n))\).
Basique Maths	L3::FDI::P et NP	Théorème de Cook-Lewis	Le problème \(SAT\) de satisfaisabilité d'un circuit booléen est \(NP\)-complet.
