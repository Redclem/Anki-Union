#separator:tab
#html:false
#notetype column:1
#deck column:2
Basique Maths	Seconde année::Informatique::Classes de complexité	Valeur atomique	Valeur numérique / alphanumérique représentable sur un nombre fini fixe de bits
Basique Maths	Seconde année::Informatique::Classes de complexité	Opération élémentaire	Une opération élémentaire est l'une des opérations suivantes sur des valeurs atomiques: - lecture / écriture - opération arithmétique - comparaison
Basique Maths	Seconde année::Informatique::Classes de complexité	Temps d'exécution	le temps d'exécution d'un algorithme \( \mathcal A \) sur l'entrée \( x \) est le nombre d'opérations élémentaires effectuées par \( \mathcal A(x)\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Classe de complexité	Ensemble de problèmes
Basique Maths	Seconde année::Informatique::Classes de complexité	\(DTIME\)	Pour \( t : \mathbb N \to \mathbb N \) , on note \( DTIME(t(n)) \) l'ensemble des problèmes de décision qui peuvent être résolus par un algorithme dont le temps d'exécution est inférieur ou égal à \( \alpha(t(|x|)) \) pour toute entrée \( x \) pour un certain \( \alpha \) qui ne dépend pas de \( x \) . Si \( T \) est un ensemble de fonctions, on note \( DTIME(T) = \bigcup\limits_{t \in T}DTIME(t(n))\).
Basique Maths	Seconde année::Informatique::Classes de complexité	Prédicat	Soit \( A \) un problème de décision d'instances \( I_A \) . On note \( p_A : \begin{array}{ll} I_A \to \mathbb B \\ x \to \begin{array}{ll} \text{vrai si x instance positive}\\ \text{faux sinon} \end{array} \end{array} \) le prédicat associé à \( A\).
Basique Maths	Seconde année::Informatique::Classes de complexité	Classes usuelles de complexité et inclusions	- \( P = DTIME(n^{\mathcal O(1)}) = \bigcup\limits_{k \in \mathbb N} DTIME(n^k) \)  - \( EXP = DTIME(2^{n^{\mathcal O(1)}}) \)  - \( 2-EXP = DTIME(2^{2^{n^{\mathcal O(1)}}}) \)  - \( E = DTIME(2^{\mathcal O(n)}) \)   \( P \subsetneq E \subsetneq EXP \subsetneq 2-EXP\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Classe NP	Ensemble des problèmes \( \mathcal A \) tels qu'il existe: - Un ensemble \( C \) de certificats - Un problème \( B \in P \) tel que \( I_B = I_A \times C \)  - Une fonction polynomiale \( s \) vérifiant:  \( \forall x \in I_A, p_A(x) \Leftrightarrow\exists c \in C, |c| \le s(|x|)\wedge p_B(x,c)\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Relation \(P\) et \(NP\)	 \( P \subseteq NP\)
Basique Maths	Seconde année::Informatique::Classes de complexité	\(NTIME\)	Pour \( t : \mathbb N \to \mathbb N \) , on note \( NTIME(t(n)) \) l'ensemble des problèmes de décision qui peuvent être résolus par un algorithme non déterministe dont le temps d'exécution est inférieur ou égal à \( \alpha(t(|x|)) \) pour toute entrée \( x \) pour un certain \( \alpha \) qui ne dépend pas de \( x \) . Si \( T \) est un ensemble de fonctions, on note \( NTIME(T) = \bigcup\limits_{t \in T}NTIME(t(n))\).
Basique Maths	Seconde année::Informatique::Classes de complexité	\(NP\) selon \(NTIME\)	 \( NP = NTIME(n^{\mathcal O(1)})\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Problèmes \(NP\)-complets usuels	- \( SAT \)  - \( 3-SAT \)  - \( CHO\) : Chemin hamiltonien (1 seule fois par sommet) dans un graphe orienté
Basique Maths	Seconde année::Informatique::Classes de complexité	Algorithme non déterministe	Algorithme qui dispose de l'opération de choix non déterministe d'une valeur atomique.
Basique Maths	Seconde année::Informatique::Classes de complexité	Réduction many-one polynomiale	Avec \( A \) et \( B \) deux problèmes, il existe une réduction many-one polynomiale de \( A \) à \( B \) noté \( A \le_m^p B \) ssi il existe \( f : I_A \to I_B \) calculable en temps polynomial telle que:  \( \forall x \in I_A, p_A(x) \Leftrightarrow p_B(f(x))\).
Basique Maths	Seconde année::Informatique::Classes de complexité	Réductions et classes	Soient \( A \) et \( B \) tels que \( A \le_m^pB \) . Alors: - \( B \in P \Rightarrow A \in P \)  - \( B \in NP \Rightarrow A \in NP\)
Basique Maths	Seconde année::Informatique::Classes de complexité	\(\mathcal C\)-difficulté / \(\mathcal C\)-complétude	Soit \( \mathcal C \) un classe super-polynomiale (contenant \( P \) ) et \( B \) un problème de décision - \( B \) est \( \mathcal C \) -difficile (ou \( \mathcal C \) -dur) ssi \( \forall A \in \mathcal C, A\le_m^pB \)  - \( B \) est \( \mathcal C \) -complet ssi \( B \in \mathcal C \) et \( B \) est \( \mathcal C\)-difficile
Basique Maths	Seconde année::Informatique::Classes de complexité	Co-classe	\( co\mathcal C \) est définie par:  \( A \in co\mathcal C \Leftrightarrow coA \in \mathcal C\)
Basique Maths	Seconde année::Informatique::Classes de complexité	\(PSPACE\) / \(NPSPACE\)	 \( PSPACE \) (resp. \( NPSPACE\)) est l'ensemble des problèmes de décision résolus par un algorithme déterministe (resp. non déterministe) de complexité spatiale polynomiale.
Basique Maths	Seconde année::Informatique::Classes de complexité	Relation \(PSPACE / NPSPACE\)(Théorème de Savitch)	 \( PSPACE = NPSPACE\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Relation\(P, NP, PSPACE, NPSPACE, EXP\)	 \( P \subseteq NP \subseteq PSPACE = NPSPACE \subseteq EXP \)
Basique Maths	Seconde année::Informatique::Classes de complexité	Problème\(QSAT\)et complétude	\( QSAT \) : - Instance : \( \varphi \) une formule booléenne quantifiée - Question : \( \varphi \) est-elle satisfiable est \( PSPACE\)-complet.
Basique Maths	Seconde année::Informatique::Classes de complexité	Branch and Bound	Pour un problème \( \Pi \) d'optimisation de la mesire \( f \) ; on suppose disposer - d'une heuristique d'évaluation \( h \) qui évalue une solution partielle, qui est admissible (i.e. optimiste) - d'une heuristique de branchement \( b \) qui pour une solution partielle renvoie la liste des manières de la continuer, dans un certain ordre Pour chaque solution \( \tilde y \) : - Si elle est finale, on met à jour la meilleure solution \( y_{min} \) si elle l'améliore et sa mesure \( f_{min} \)  - Sinon, si \( h(\tilde y) < f_{min} \) , on exécute récursivement sur chaque complétion dans \( b(\tilde y)\).
