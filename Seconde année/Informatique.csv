#separator:tab
#html:false
#notetype column:1
#deck column:2
Basique Maths	Seconde année::Informatique::Graphes	Nombres d'arêtes d'un graphe non orienté selon les degrés	Dans un graphe non orienté, \( 2|A| = \sum\limits_{s \in S}d(s)\).
Basique Maths	Seconde année::Informatique::Graphes	Parcours préfixe	Ordre obtenu en parcourant un graphe en profondeur, en marquant chaque sommet en l'atteignant la première fois
Basique Maths	Seconde année::Informatique::Graphes	Parcours postfixe	Ordre obtenu en parcourant un graphe en profondeur, en marquant chaque sommet après avoir terminé le parcours depuis celui ci
Basique Maths	Seconde année::Informatique::Graphes	Intersection des intervalles \([pre(s), post(s)]\)	Dans un graphe orienté, \( \forall (s,t) \in S^2, [pre(s), post(s)] \text{ et }[pre(t), post(t)]\) sont disjoints, ou l'un est inclus dans l'autre
Basique Maths	Seconde année::Informatique::Graphes	Caractérisation d'un cycle par les parcours	Dans un graphe \( G=(S,A) \) orienté, les psse: - \( G \) contient un cycle - Il existe \( (s,t) \in A \) telle que \( post(s) < post(t)\)
Basique Maths	Seconde année::Informatique::Graphes	Ordre topologique	Dans un DAG, un ordre topologique des sommets de \( G \) est un ordre total \( \prec \) tel que s'il existe une arête de \( s \) à \( t \) , alors \( s \prec t \) . Si les sommets de \( G\) sont placés de gauche à droite dans un ordre topologique, toutes les arêtes pointent de la gauche vers la droite.
Basique Maths	Seconde année::Informatique::Graphes	Ordre topologique par le parcours	Soit \( G \) un DAG. L'ordre inverse du parcours postfixe de \( G\) en est un ordre topologique.
Basique Maths	Seconde année::Informatique::Graphes	Métagraphe	Le métagraphe d'un graphe orienté est le graphe orienté des composantes fortement connexes, avec une arête entre deux composantes ssi il existe une arête entre deux de leur sommets dans le sens correspondant. Le métagraphe de \( G \) est noté \( CFC(G)\)
Basique Maths	Seconde année::Informatique::Graphes	Nature du métagraphe	Soit \( G \) un graphe orienté. \( CFC(G)\) est un DAG.
Basique Maths	Seconde année::Informatique::Graphes	CFC source par le parcours postfixe	Avec \( G \) un graphe orienté, le dernier sommet d'un parcours postfixe de \( G \) est dans une CFC source de \( CFC(G)\).
Basique Maths	Seconde année::Informatique::Graphes	Graphe transposé	Le graphe transposé d'un graphe orienté est le même graphe avec les arêtes retournées:  \( (s,t) \in A^T \Leftrightarrow (t,s) \in A\).
Basique Maths	Seconde année::Informatique::Graphes	Métagraphe du graphe transposé	Pour tout graphe orienté \( G \) , \( CFC(G^T) = CFC(G)^T\).
Basique Maths	Seconde année::Informatique::Graphes	Algorithme de Kosaraju	Soit \( G \) une graphe orienté - Calculer le graphe transposé \( G^T \)  - Calculer le parcours postfixe de \( G^T \)  - Poser l'ordre inverse \( l \) de ce parcours - Pour chaque sommet \( s \) de \( l \) dans l'ordre, numéroter les sommets atteints par un parcours depuis \( s\) qui ne sont pas déja numérotés.
Basique Maths	Seconde année::Informatique::Graphes	Complexité de l'algorithme de Kosaraju	L'algorithme de Kosaraju peut être implémenté en \( \mathcal O(|S| + |A|)\)
Basique Maths	Seconde année::Informatique::Graphes	Complexité de 2-SAT	Le problème 2-SAT est résoluble en temps linéaire en la taille de la formule
Basique Maths	Seconde année::Informatique::Graphes	Graphe d'implication	Pour une formule \( \varphi \) en \( k \) -FNC sur l'ensemble de variables \( \mathcal V = \{v_1, \dots, v_n\} \) , le graphe d'implication de \( \varphi \) noté \( G_\varphi \) est défini par: - \( S = \mathcal V\cup \overline{ \mathcal V} \) , où \( \overline{\mathcal V} \) est l'ensemble des négations des variables de \( \mathcal V \) .  - \( A = \{(\overline {l_1}, l_2)|(l_1 \vee l_2)\text { est une clause de }\varphi\} \cup \{(\overline {l_2}, l_1)|(l_1 \vee l_2)\text { est une clause de }\varphi\}\)
Basique Maths	Seconde année::Informatique::Graphes	Interprétation d'un chemin dans le graphe d'implication	S'il existe un chemin de \( l_1 \) à \( l_2 \) dans \( G_\varphi \) , alors \( \varphi \models l_1 \to l_2\)
Basique Maths	Seconde année::Informatique::Graphes	Caractérisation de la satisfaisabilité par le graphe d'implication	 \( \varphi \) est satisfiable ssi aucune CFC de \( G_\varphi\) ne contient une variable et sa négation.
Basique Maths	Seconde année::Informatique::Graphes	Arbre	Graphe non orienté connexe sans cycle
Basique Maths	Seconde année::Informatique::Graphes	Connexité / caractère acyclique et cardinal	Soit \( G = (S,A) \) un graphe non orienté: - si \( G \) est connexe, \( |A| \ge |S| - 1 \)  - si \( G \) est acyclique, \( |A| \le |S| - 1\)
Basique Maths	Seconde année::Informatique::Graphes	Caractérisation des arbres	Soit \( G = (S,A) \) un graphe non orienté. Les psse: - \( G \) est un arbre - \( G \) est connexe avec \( |S| - 1 \) arêtes - \( G \) est acyclique avec \( |S| - 1\) arêtes
Basique Maths	Seconde année::Informatique::Graphes	Arbre couvrant	Soit \( G \) non orienté. Un arbre couvrant de \( G \) est un sous-graphe de \( G \) de même ordre que \( G\) qui est un arbre.
Basique Maths	Seconde année::Informatique::Graphes	Poids d'un arbre couvrant	Somme des poids des arêtes de l'arbre.
Basique Maths	Seconde année::Informatique::Graphes	Algorithme de Kruskal	Soit \( G = (S,A,f) \) un graphe non orienté connexe - On créée \( B = \varnothing\) - On parcourt les arêtes par ordre croissant de poids, en ajoutant chaque arête si elle ne créée pas de cycle
Basique Maths	Seconde année::Informatique::Graphes	Validité de l'algorithme de Kruskal	L'algorithme de Kruskal applique à \( G \) renvoie un arbre couvrant minimal de \( G\).
Basique Maths	Seconde année::Informatique::Graphes	Complexité de l'algorithme de Kruskal	L'algorithme de Kruskal appliqué à \( G = (S,A,f) \) a une complexité \( \mathcal O(|A|\log|S|)\)
Basique Maths	Seconde année::Informatique::Graphes	Algorithme A*	Pour un graphe pondéré \( G = (S,A,f) \) : - On initialise tout les coûts - Tant qu'il reste des sommets non traités:  - On traite le sommet minimisant \( cout(s) + h(s) \) , c'est à dire pour tout voisin \( t \) de \( s \) :  - si \( cout(s) + f(s,t) < cout(t) \) , il devient le nouveau coût de \( t \) et \( s\) devient son prédécésseur
Basique Maths	Seconde année::Informatique::Graphes	Heuristique consistante / admissible pour A*	Une heuristique est: - consistante ssi \( \forall(s,t) \in S^2, h(s) \le d(s,t) + h(t) \)  - admissible ssi \( \forall s \in S, h(s) \le d(s,s_f) \) , où \( s_f\) est le sommet d'arrivée
Basique Maths	Seconde année::Informatique::Graphes	CS pour l'admissibilité d'une heuristique consistante	Une heuristique consistante est admissible si \( h(s_f) = 0\)
Basique Maths	Seconde année::Informatique::Graphes	Validité de A* selon l'heuristique	Si l'heuristique est admissible, A* est garanti de trouver une solution optimale à la recherche du plus court chemin.
Basique Maths	Seconde année::Informatique::Graphes	Couplage	Un couplage d'un graphe non orienté est un ensemble d'arêtes sans sommets en commun.
Basique Maths	Seconde année::Informatique::Graphes	Couplage maximal	Un couplage \( C \) est maximal si pour tout arête \( a \notin c, C \cup \{a\}\) n'est pas un couplage
Basique Maths	Seconde année::Informatique::Graphes	Couplage maximum	Couplage de cardinal maximum
Basique Maths	Seconde année::Informatique::Graphes	Relation couplage maximal et maximum	Un couplage maximum est maximal
Basique Maths	Seconde année::Informatique::Graphes	Chemin alternant et augmentant	Soit \( G = (S,A) \) un graphe non orienté et \( C \subset A \) un couplage de \( G \) . On appelle: - Chemin alternant un chemin dont les arêtes sont alternativement dans \( C \) et \( A \setminus C \)  - Chemin augmentant un chemin alternant qui commence et termine par des sommets libres pour \( C\).
Basique Maths	Seconde année::Informatique::Graphes	Théorème de Berge	Un couplage \( C \) est maximum ssi il n'existe pas de chemin augmentant pour \( C\).
Basique Maths	Seconde année::Informatique::Graphes	Graphe orienté associé à un couplage dans un graphe biparti	Avec \( G =(X \sqcup Y ,A) \) biparti et \( C \) un couplage de \( G \) , le graphe orienté associé à \( C \) noté \( G_C = (S', A') \) est défini par: - \( S' = S\cup \{s,t\} \)  - pour tout \( x\in X, (s,x) \in A' \) ssi \( s \) n'est pas apparié dans \( C \)  - pour tout \( y\in Y, (y,t) \in A' \) ssi \( t \) n'est pas apparié dans \( C \)  - \( \forall (x,y) \in A \) avec \( x \in X, y \in Y \) , \( (x,y) \in A' \) ssi \( \{x,y\} \notin C \) et \( (y,x) \in A' \) ssi \( \{x,y\} \in C\)
Basique Maths	Seconde année::Informatique::Graphes	Caractérisation des chemins augmentants de \(C\) par les chemins dans \(G_c\)	Avec \( G =(S,A) \) biparti et \( C \) un couplage de \( G \) , il existe un chemin augmentant pour \( C \) ssi il existe un chemin de \( s \) à \( t \) dans \( G_c\) et ces chemins correspondent (en retirant les extrémités de ce dernier)
Basique Maths	Seconde année::Informatique::Graphes	Complexité de la recherche de couplage maximum	L'algorithme de recherche de couplage maximum dans un graphe biparti \( G=  (S,A) \) s'effectue avec une complexité \( \mathcal O(|S||A|)\)
Basique Maths	Seconde année::Informatique::Langages et automates	Lemme de Levi	Soient \( x, y, u, v \in \Sigma^* \) tels que \( xy = uv \) . Alors il existe un unique mot \( w \) tel que l'une des conditions suivante est réalisée: - \( x = uw \) et \( v = wy \)  - \( u = xw \) et \( y = wv\)
Basique Maths	Seconde année::Informatique::Langages et automates	Langage reconnaissable	Un langage \( L \) est reconnaissable s'il existe un AFD \( A \) tel que \( L(A) = L \) . On note \( Rec(\Sigma) \) l'ensemble des langages reconnaissables sur \( \Sigma\).
Basique Maths	Seconde année::Informatique::Langages et automates	Automates équivalents	Deux automates sont équivalents s'ils reconnaissent le même langage.
Basique Maths	Seconde année::Informatique::Langages et automates	Blocage	Un blocage est un couple \( (q,a) \in Q\times \Sigma\) pour lequel la fonction de transition n'est pas définie
Basique Maths	Seconde année::Informatique::Langages et automates	Automate complet	Automate sans blocage
Basique Maths	Seconde année::Informatique::Langages et automates	Automate complet reconnaissant un langage reconnaissable	Tout langage reconnaissable est reconnu par un automate complet.
Basique Maths	Seconde année::Informatique::Langages et automates	Automate émondé reconnaissant un langage reconnaissable	Tout langage reconnaissable non vide est reconnu par un automate émondé.
Basique Maths	Seconde année::Informatique::Langages et automates	Automate standard	Automate sans transition vers l'état initial
Basique Maths	Seconde année::Informatique::Langages et automates	Automate standard reconnaissant un langage reconnaissable	Tout langage reconnaissable est reconnu par un automate standard.
Basique Maths	Seconde année::Informatique::Langages et automates	Taille minimale d'un automate déterministe par rapport à un non déterministe	Pour \( n \in \mathbb N^* \) , il existe un langage \( L \) reconnu par un AFND à \( n + 1 \) états et non reconnu par un AFD à moins de \( 2^n\)états.
Basique Maths	Seconde année::Informatique::Langages et automates	Ensemble des langages rationnels	Avec \( \Sigma \) un alphabet, on appelle ensemble des langages rationnels sur \( \Sigma \) noté \( Rat(\Sigma) \) le sous-ensemble de \( \prts(E) \) défini par induction par: - \( \varnothing \in Rat(\Sigma) \)  - \( \forall a \in \Sigma, \{a\} \in Rat(\Sigma) \)  - \( Rat(\Sigma)\) est stable par concaténation, union et étoile.
Basique Maths	Seconde année::Informatique::Langages et automates	Expression régulières	On définit l'ensemble des expressions régulières sur \( \Sigma \) par induction par: - \( \varnothing \) est une expression régulière - pour tout \( a \in \Sigma, a \) est une expression régulière - Si \( e, f \) sont des expressions régulières, \( ef, e | f, e^\star\) sont des expressions régulières.
Basique Maths	Seconde année::Informatique::Langages et automates	Equivalence langage rationnel / expression régulière	Un langage est rationnel si et seulement s'il est l'interprétation d'une expression régulière.
Basique Maths	Seconde année::Informatique::Langages et automates	Théorème de Kleene	Pour tout alphabet \( \Sigma \) , \( Rec(\Sigma) = Rat(\Sigma)\)
Basique Maths	Seconde année::Informatique::Langages et automates	Automate généralisé	Automate dont les transitions sont étiquetées par des expressions régulières.
Basique Maths	Seconde année::Informatique::Langages et automates	Complémentaires et intersection de langages rationnels	Le complémentaire et l'intersection de langages rationnels sont des langages rationnels
Basique Maths	Seconde année::Informatique::Langages et automates	Lemme de pompage	Soit \( L \in Rat(\Sigma) \) . Alors il existe un entier \( n \in \mathbb N^* \) , appelé longueur de pompage, tel que pour tout mot \( u \in L \) tel que \( |u| \ge n \) admet une décomposition de la forme \( xyz \) telle que: - \( y \ne \varepsilon \)  - \( |xy| \le n \)  - \( \forall k \in \mathbb N, xy^kz \in L\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Valeur atomique	Valeur numérique / alphanumérique représentable sur un nombre fini fixe de bits
Basique Maths	Seconde année::Informatique::Classes de complexité	Opération élémentaire	Une opération élémentaire est l'une des opérations suivantes sur des valeurs atomiques: - lecture / écriture - opération arithmétique - comparaison
Basique Maths	Seconde année::Informatique::Classes de complexité	Temps d'exécution	le temps d'exécution d'un algorithme \( \mathcal A \) sur l'entrée \( x \) est le nombre d'opérations élémentaires effectuées par \( \mathcal A(x)\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Classe de complexité	Ensemble de problèmes
Basique Maths	Seconde année::Informatique::Classes de complexité	\(DTIME\)	Pour \( t : \mathbb N \to \mathbb N \) , on note \( DTIME(t(n)) \) l'ensemble des problèmes de décision qui peuvent être résolus par un algorithme dont le temps d'exécution est inférieur ou égal à \( \alpha(t(|x|)) \) pour toute entrée \( x \) pour un certain \( \alpha \) qui ne dépend pas de \( x \) . Si \( T \) est un ensemble de fonctions, on note \( DTIME(T) = \bigcup\limits_{t \in T}DTIME(t(n))\).
Basique Maths	Seconde année::Informatique::Classes de complexité	Prédicat	Soit \( A \) un problème de décision d'instances \( I_A \) . On note \( p_A : \begin{array}{ll} I_A \to \mathbb B \\ x \to \begin{array}{ll} \text{vrai si x instance positive}\\ \text{faux sinon} \end{array} \end{array} \) le prédicat associé à \( A\).
Basique Maths	Seconde année::Informatique::Classes de complexité	Classes usuelles de complexité et inclusions	- \( P = DTIME(n^{\mathcal O(1)}) = \bigcup\limits_{k \in \mathbb N} DTIME(n^k) \)  - \( EXP = DTIME(2^{n^{\mathcal O(1)}}) \)  - \( 2-EXP = DTIME(2^{2^{n^{\mathcal O(1)}}}) \)  - \( E = DTIME(2^{\mathcal O(n)}) \)   \( P \subsetneq E \subsetneq EXP \subsetneq 2-EXP\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Classe NP	Ensemble des problèmes \( \mathcal A \) tels qu'il existe: - Un ensemble \( C \) de certificats - Un problème \( B \in P \) tel que \( I_B = I_A \times C \)  - Une fonction polynomiale \( s \) vérifiant:  \( \forall x \in I_A, p_A(x) \Leftrightarrow\exists c \in C, |c| \le s(|x|)\wedge p_B(x,c)\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Relation \(P\) et \(NP\)	 \( P \subseteq NP\)
Basique Maths	Seconde année::Informatique::Classes de complexité	\(NTIME\)	Pour \( t : \mathbb N \to \mathbb N \) , on note \( NTIME(t(n)) \) l'ensemble des problèmes de décision qui peuvent être résolus par un algorithme non déterministe dont le temps d'exécution est inférieur ou égal à \( \alpha(t(|x|)) \) pour toute entrée \( x \) pour un certain \( \alpha \) qui ne dépend pas de \( x \) . Si \( T \) est un ensemble de fonctions, on note \( NTIME(T) = \bigcup\limits_{t \in T}NTIME(t(n))\).
Basique Maths	Seconde année::Informatique::Classes de complexité	\(NP\) selon \(NTIME\)	 \( NP = NTIME(n^{\mathcal O(1)})\)
Basique Maths	Seconde année::Informatique::Classes de complexité	Problèmes \(NP\)-complets usuels	- \( SAT \)  - \( 3-SAT \)  - \( CHO\) : Chemin hamiltonien (1 seule fois par sommet) dans un graphe orienté
Basique Maths	Seconde année::Informatique::Classes de complexité	Algorithme non déterministe	Algorithme qui dispose de l'opération de choix non déterministe d'une valeur atomique.
Basique Maths	Seconde année::Informatique::Classes de complexité	Réduction many-one polynomiale	Avec \( A \) et \( B \) deux problèmes, il existe une réduction many-one polynomiale de \( A \) à \( B \) noté \( A \le_m^p B \) ssi il existe \( f : I_A \to I_B \) calculable en temps polynomial telle que:  \( \forall x \in I_A, p_A(x) \Leftrightarrow p_B(f(x))\).
Basique Maths	Seconde année::Informatique::Classes de complexité	Réductions et classes	Soient \( A \) et \( B \) tels que \( A \le_m^pB \) . Alors: - \( B \in P \Rightarrow A \in P \)  - \( B \in NP \Rightarrow A \in NP\)
Basique Maths	Seconde année::Informatique::Classes de complexité	\(\mathcal C\)-difficulté / \(\mathcal C\)-complétude	Soit \( \mathcal C \) un classe super-polynomiale (contenant \( P \) ) et \( B \) un problème de décision - \( B \) est \( \mathcal C \) -difficile (ou \( \mathcal C \) -dur) ssi \( \forall A \in \mathcal C, A\le_m^pB \)  - \( B \) est \( \mathcal C \) -complet ssi \( B \in \mathcal C \) et \( B \) est \( \mathcal C\)-difficile
Basique Maths	Seconde année::Informatique::Classes de complexité	Co-classe	\( co\mathcal C \) est définie par:  \( A \in co\mathcal C \Leftrightarrow coA \in \mathcal C\)
Basique Maths	Seconde année::Informatique::Classes de complexité	\(PSPACE\) / \(NPSPACE\)	 \( PSPACE \) (resp. \( NPSPACE\)) est l'ensemble des problèmes de décision résolus par un algorithme déterministe (resp. non déterministe) de complexité spatiale polynomiale.
Basique Maths	Seconde année::Informatique::Classes de complexité	Relation \(PSPACE / NPSPACE\)(Théorème de Savitch)	 \( PSPACE = NPSPACE\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	\(OPT_\pi(x)\)	Pour un problème d'optimisation \( \pi \) de mesure \( f \) , pour \( x \in I_\pi \) , on note \( OPT_\pi(x) \) la mesure d'une solution optimale du problème \( \pi \) pour l'instance \( x\).
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Algorithme d'approximation de facteur \(\alpha\)	Pour \( \alpha > 0 \) , on définit un algorithme d'approximation de facteur \( \alpha \) , ou \( \alpha \) -approximation, de \( \pi \) comme un algorithme \( \mathcal A \) qui renvoie une solution de \( \pi \) tel que: - Si \( \pi \) est une minimisation, \( \alpha > 1 \) et:  \( \forall x \in I_\pi, f(x, \mathcal A(x)) \le \alpha OPT_\pi(x) \)  - Si \( \pi \) est une maximisation, \( \alpha < 1 \) et:  \( \forall x \in I_\pi, f(x, \mathcal A(x)) \ge \alpha OPT_\pi(x)\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	PTAS	Un PTAS est un algorithme \( \mathcal A(x, \varepsilon) \) qui donne une solution à un facteur \( 1 - \varepsilon \) ou \( 1 + \varepsilon \) (selon le type de l'algorithme) en temps polynomial en \( |x|\) 
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	FTPTAS	C'est un PTAS en temps polynomial en \( |x| \) et \( \frac{1}{\varepsilon}\).
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Algorithme probabiliste	Un algorithme probabiliste est un algorithme où on rajoute l'opération de choix aléatoire.
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Types d'algorithmes probabilistes	Toujours vrai, temps pouvant varier: Las Vegas (lente vérité) Peut se tromper, temps identique: Monte Carlo (mensonge céleste) Peut se tromper, temps pouvant varier: Atlantic City (Hors programme)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Complexité tri rapide randomisé	La complexité temporelle attendue du tri rapide randomisé est \( O(n \log n)\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Algorithme Monte Carlo	Un algorithme Monte Carlo est un algorithme probabiliste dont le temps de calcul est toujours le même pour une entrée mais dont le résultat peut être faux.
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Faux positif / Faux négatif	On appelle faux positif (resp. faux positif) une exécution d'un algorithme Monte Carlo qui renvoie VRAI (resp. FAUX) pour une instance négative (resp. positive).
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Construction d'un algorithme Las Vegas depuis Monte Carlo	Soit \( \mathcal A \) un algorithme Monte Carlo. On suppose disposer d'un vérificateur \( \mathcal V \) permettant de vérifier une solution. Alors on peut construire un algorithme Las Vegas en alternant des exécutions de \( \mathcal A \) et \( \mathcal V \) . Si la probabilité d'erreur de \( \mathcal A \) est \( p \) , et que les temps d'exécution sur des entrées de taille \( n \) de \( \mathcal A \) et \( \mathcal V \) sont respectivement \( f(n) \) et \( g(n) \) , l'espérance du temps d'exécution est \( \frac{1}{1-p}(f(n)+g(n))\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Treap	Un treap est un arbre binaire étiqueté par des triplets \( (c,p,v)\) (clé, priorité, valeur). L'arbre contenant les clés est un ABR, l'arbre contenant les priorités est un arbre tournoi.
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Insertion dans un treap	Pour insérer une clé \( c \) dans un treap \( T \) : - Choisir aléatoirement \( p \)  - Insérer \( (c,p) \) dans \( T \) par l'algorithme d'insertion dans un \( ABR \) . - Tant que \( x \) n'est pas racine et que \( p < prio(père(x))\):faire une rotation du noeud
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Espérance de la hauteur d'un treap	Soit \( T \) un treap obtenu par insertions et suppressions successives. Alors \( \mathbb E(h(T)) = \mathcal O(log|T|)\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	BPP / PP	On appelle BPP (Bounded error Probabilistic Polynomial time) l'ensemble des problèmes qui peuvent être résolus par un algorithme Monte Carlo avec une probabilité d'erreur \( < \frac{1}{3} \) . On appelle PP la classe analogue avec une probabilité d'erreur \( < \frac{1}{2}\).
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	RP / coRP	On appelle RP (Randomized polynomial time) comme l'ensemble des problèmes qui peuvent être résolus par un algorithme Monte Carlo dont la probabilité de faux positif est nulle et la probabilité de faux négatif est \( < \frac{1}{2} \) . On définit de même coRP avec une probabilité de faux négatif nulle et une probabilité de faux positif \( < \frac{1}{2}\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Inclusions des classes probabilistes	\( P \subseteq RP \subseteq BPP \subseteq PP \subseteq PSPACE \)   \( P \subseteq coRP \subseteq BPP\)
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	ZPP	On définit ZPP (Zero-error polynomial time) comme l'ensemble des problèmes résolus par algorithme Las Vegas dont l'espérance du temps de calcul est polynomiale.
Basique Maths	Seconde année::Informatique::Stratégies algorithmiques	Relation ZPP, P, RP, coRP	- \( P \subseteq ZPP \)  - \( ZPP = RP \cap coRP\)
Basique Maths	Seconde année::Informatique::Langages algébriques	Grammaire hors contexte	Une grammaire hors contexte (CFG : Context Free Grammar) est un quadruplet \( (\Sigma, V, P, S) \) , avec: - \( \Sigma \) un alphabet d'éléments dits terminaux - \( V \) un alphabet de variables : \( \Sigma \cap V = \varnothing \)  - \( S \) est le symbole de départ - \( P \subseteq V \times (\Sigma \cup V)^*\) est l'ensemble fini des règles de production
Basique Maths	Seconde année::Informatique::Langages algébriques	Règle, notation	Une règle est un couple \( (X, \alpha) \in V \times (\Sigma \cup V)^* \) , notée \( X \rightarrow \alpha\)
Basique Maths	Seconde année::Informatique::Langages algébriques	Dérivation immédiate, dérivation	Si \( X \rightarrow \alpha \in P; \beta, \gamma \in (\Sigma \cup V)^* \) , on dit que \( \beta X \gamma \) se dérive immédiatement en \( \beta \alpha \gamma \) , noté \( \beta X \gamma \Rightarrow\beta \alpha \gamma \) . Une dérivation est une suite de dérivations immédiates. On note \( \Rightarrow^* \) la clôture réflexive et transitive de \( \Rightarrow\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Langage engendré / Langage algébrique	Pour une CFG \( G = (\Sigma, V, P,S) \) , on définit le langage engendré par \( G \) comme:  \( L(G) = \{u \in \Sigma^*|S\Rightarrow^*u\} \)  Un langage est algébrique ssi il est engendré par une CFG. On note \( Alg(\Sigma) \) l'ensemble des langages algébriques sur l'alphabet \( \Sigma\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Opération stabilisant \(Alg(G)\)	 \( Alg(\Sigma)\) est clos par union, concaténation et étoile.
Basique Maths	Seconde année::Informatique::Langages algébriques	Relation langages rationnels et algébriques	 \( Rat(\Sigma) \subseteq Alg(\Sigma)\)
Basique Maths	Seconde année::Informatique::Langages algébriques	Grammaire régulière	Soit \( G = (\Sigma, V, P, S) \) une CFG.  \( G \) est régulière à droite (resp. à gauche) ssi \( P \) ne contient que des règles de la forme: - \( X \to \varepsilon \)  - \( X\to a, a \in \Sigma \)  - \( X\to Ya \) (resp. \( X \to aY \) ), \( Y \in V, a \in \Sigma \)   \( G\) est régulière si elle est régulière à gauche ou à droite.
Basique Maths	Seconde année::Informatique::Langages algébriques	Grammaire engendrant un langage rationnel	 \( L \in Rat(\Sigma) \) ssi \( L\) est engendré par une grammaire régulière.
Basique Maths	Seconde année::Informatique::Langages algébriques	Lemme fondamental	Soit \( G = (\Sigma, V, P, S) \) une CFG, \( \alpha_1, \alpha_2, \beta \in (\Sigma \cup V)^* \) et \( n \in \N \) . Les psse: - \( \alpha_1\alpha_2 \Rightarrow^n \beta \)  - \( \exists \beta_1, \beta_2 \in (\Sigma \cup V)^*, n_1, n_2 \in \mathbb N \) tels que:  \( \alpha_1\Rightarrow^{n_1} \beta_1, \alpha_2\Rightarrow^{n_2} \beta_2 \) et \( \beta_1\beta_2= \beta, n_1 + n_2 = n\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Dérivation immédiate gauche / droite	Soit \( G = (\Sigma, V, P, S) \) une CFG et \( X \to \alpha \in P; \beta, \gamma \in (\Sigma \cup V)^*, u \in \Sigma^* \) . Alors une dérivation immédiate gauche est de la forme \( uX\delta \Rightarrow u \alpha \delta \) , une dérivation immédiate droite de la forme \( \beta X u \Rightarrow  \beta \alpha u\)
Basique Maths	Seconde année::Informatique::Langages algébriques	Arbre de dérivation	Un arbre de dérivation de \( u \in L(G) \) est un arbre étiqueté par des éléments de \( \Sigma \cup V \cup \{\varepsilon\} \) tel que: - La racine est \( S \)  - Les noeuds internes sont étiquetés sur \( V \)  - Les feuilles sont étiquetées sur \( \Sigma \cup \{ \varepsilon\} \)  - La lecture des feuilles de gauche à droite forme le mot \( u \)  - Si \( X \in V \) étiquette un noeud interne ayant pour fils \( \alpha_1, \dots, \alpha_k, k \ge 1 \) , alors \( X \rightarrow \alpha_1 \dots \alpha_k \in P \) , et si \( k > 1, \alpha_1, \dots, \alpha_k \ne \varepsilon\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Ambiguité	Avec \( G \) une CFG, \( u \in L(G) \) est ambigu pour \( G \) s'il existe deux arbres de dérivation différents de \( u \) dans \( G \) . \( G \) est ambigue s'il existe un mot ambigu pour \( G\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Équivalence faible	 \( G_1 \) et \( G_2 \) sont faiblement équivalentes si \( L(G_1) = L(G_2)\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Caractérisation de l'ambiguité par les dérivations gauches / droites	Soit \( G \) une CFG, et \( u\in L(G) \) . Il y a équivalence entre: - \( u \) est ambigu pour \( G \)  - \( u \) possède plusieurs dérivations gauches - \( u\) possède plusieurs dérivations droites
Basique Maths	Seconde année::Informatique::Langages algébriques	Décidabilité du problème de l'ambiguité	Le problème de décision AMBIGUITE qui consiste à déterminer si une grammaire est ambiguë est indécidable.
Basique Maths	Seconde année::Informatique::Langages algébriques	Ambiguité intrinsèque	 \( L \in Alg(\Sigma)\) est intrinsèquement ambigu si toute CFG qui l'engendre est ambiguë.
Basique Maths	Seconde année::Informatique::Langages algébriques	Exemple de langage intrinsèquement ambigu	 \( \{a^ib^jc^k|i=j \vee j = k\}\) est intrinsèquement ambigu.
Basique Maths	Seconde année::Informatique::Langages algébriques	Forme normale de Chomsky	Une CFG \( G \) est en forme normale de Chomsky (FNC) si toutes les règles sont: - \( S \rightarrow \varepsilon \)  - \( X \to YZ, Y, Z\in V \setminus\{S\} \)  - \( X \rightarrow a, a \in \Sigma\)
Basique Maths	Seconde année::Informatique::Langages algébriques	Équivalence à une CFG en FNC	Toute CFG est faiblement équivalente à une CFG en FNC.
Basique Maths	Seconde année::Informatique::Langages algébriques	Taille d'un mot selon son arbre de dérivation en FNC	Soit \( G \) une CFG en FNC et \( u \in L(G) \) . Soit \( A \) un arbre de dérivation de \( u \) . Alors \( |u| \le 2^{h(A) - 1}\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Lemme de pompage algébrique	Soit \( L \in Alg(\Sigma) \) . Alors il existe \( n \in \N^* \) (longueur de pompage) tel que \( \forall u \in L \) , Si \( |u| \ge n \) , alors il existe une décomposition \( u = vwxyz \) vérifiant: - \( |wxy|\le n \)  - \( wy \ne \varepsilon \)  - \( \forall k \in \N, vw^kxy^kz \in L\)
Basique Maths	Seconde année::Informatique::Langages algébriques	Exemple de langage non algébrique	 \( L = \{a^nb^n c^n, n \in \N\}\) n'est pas un langage algébrique.
Basique Maths	Seconde année::Informatique::Apprentissage	Types de problèmes d'apprentissage	- Classification : catégoriser une entrée - Régression : associer une valeur numérique à une entrée - Partitionnement / Clustering : on veut créer des classes d'équivalence dans un ensemble de données
Basique Maths	Seconde année::Informatique::Apprentissage	Apprentissage supervisé / non supervisé	L'apprentissage est supervisé si on connaît déja de l'information sur certaines données. Si on n'a pas d'information, l'apprentissage est non supervisé.
Basique Maths	Seconde année::Informatique::Apprentissage	Algorithme des K plus proches voisins	Pour catégoriser \( x \) , on trouve les \( k\) plus proches voisins parmi les points connus, et on renvoie la catégorie majoritaire dans ces éléments. On peut utiliser plusieurs normes. 
Basique Maths	Seconde année::Informatique::Apprentissage	Une complexité possible de l'algorithme des \(k\) plus proches voisins	L'algorithme des \( k \) plus proches voisins peut être implémenté en \( O(N)\). 
Basique Maths	Seconde année::Informatique::Apprentissage	Matrice de confusion	Avec des données \( X \) , une classification \( c : X \to \{1, \dots, m\} \) et un fonction de classification \( f \) , la matrice de confusion est \( M = (m_{i,j}) \) , où \( m_{i,j} = |\{x \in X | c(x) = i, f(x) = j\}|\)
Basique Maths	Seconde année::Informatique::Apprentissage	Arbre k-dimensionnel	Un arbre \( d \) -dimensionnel est un arbre binaire dont les noeuds sont étiquetés de telle manière que: - pour chaque noeud \( x \) , les noeuds dans le fils gauche et le fils droit de \( x \) sont séparés par un hyperplan passant par \( x \) . - si le noeud \( x \) est de profondeur \( \equiv p[d] \) , alors cet hyperplan est normal au vecteur \( e_{p+1}\).
Basique Maths	Seconde année::Informatique::Apprentissage	Complexité de la recherche des plus proches voisins dans un arbre k-dimensionnel	Dans un arbre \( d \) -dimensionnel, la complexité de la recherche des \( K \) plus proches voisins est: - en moyenne \( \mathcal O(K(\log( K) + d) + d \log (N)) \)  - dans le pire cas \( \mathcal O(N(d + \log N))\)
Basique Maths	Seconde année::Informatique::Apprentissage	Arbre de décision	Un arbre de décision est un arbre dont: - les feuilles sont étiquetées par des numéros de classes - les noeuds internes sont des questions / des attributs et les fils correspondent chacun à une réponse / une valeur / un plage de valeurs.
Basique Maths	Seconde année::Informatique::Apprentissage	Entropie de Shannon	On définit l'entropie de Shannon de \( E \) :  \( H(E) = -\sum\limits_{j = 1}^m\frac{|C_j|}{N}\log(\frac{|C_j|}{N}) \) , où \( C_j = \{x \in E | c(x) = j\}\).
Basique Maths	Seconde année::Informatique::Apprentissage	Gain d'entropie	Avec \( E_{a = a_k} = \{x \in E | a(x) = a_k\} \) , le gain d'entropie selon \( a \) est  \( G(E,a) = H(E) - \sum\limits_{k = 1}^p\frac{|E_{a = a_k}|}{N}H(E_{a = a_k})\)
Basique Maths	Seconde année::Informatique::Apprentissage	Algorithme ID3	- Si tous les éléments de \( E \) sont dans la même classe : créér une feuille correspondant à cette classe - Si \( E = \varnothing \) : on crée une feuille correspondant à la classe majoritaire du noeud parent. - Sinon, soit \( a \) l'attribut qui maximise \( G(E,a) \) . On construit un noeud \( a \) ayant pour fils les arbres construits par récurrence sur \( E_{a=a_1}, \dots, E_{a = a_k}\)
Basique Maths	Seconde année::Informatique::Apprentissage	Clustering hiérarchique ascendant (CHA)	On créé une classe par élément, et on fusionne les deux classes les plus proches tant que nécéssaire
Basique Maths	Seconde année::Informatique::Apprentissage	Problème CLUSTERING	Le problème CLUSTERING consiste à partitionner un ensemble \( E \) en un nombre fini de classes \( C_1, \dots, C_m \) pour minimiser \( \sum\limits_{j = 1}^m\sum_{x \in C_j}\delta(x, b_j)^2\). CLUSTERING est NP-difficile.
Basique Maths	Seconde année::Informatique::Apprentissage	Algorithme des k-moyennes	- Créer des points \( b_1, \dots, b_m \) au hasard - Tant que nécéssaire: *Créer les classes associées aux \( (b_i) \)  *Mettre à jour les barycentres \( (b_i)\)
Basique Maths	Seconde année::Informatique::Apprentissage	Complexité des k-moyennes	Chaque itération des k-moyennes a une complexité \( \mathcal O(m \times N \times d)\).
Basique	Seconde année::Informatique::Logique	Formule propositionnelle	Avec \(V\) un ensemble de variables propositionnelles, les formules propositionnelles propositionnelles sur \(V\) sont définies par induction: - \(\top, \bot\), et les variables de \(V\) sont des formules propositionnelles - Les opérateurs \(\neg, \wedge, \vee, \Rightarrow\) appliqués à des formules propositionnelles, sont des variables propositionnelles.
Basique	Seconde année::Informatique::Logique	Arbre binaire associé à une formule	On associe l'arbre \(A(\varphi)\) à la formule propositionnelle \(\varphi\): - \(A(\varphi)\) est une feuille \(\varphi\) si \(\varphi \in V \cup \{\top, \bot\}\) - Si \(\varphi = \neg \psi, A(\varphi) = N(\neg, A(\varphi))\) - Si \(\varphi = \psi \wedge \sigma, A(\varphi) = N(\wedge, \varphi, \sigma)\), et de même pour \(\vee, \Rightarrow\)
Basique	Seconde année::Informatique::Logique	Valuation	Une valuation est une fonction de \(\{0, 1\}^V\).
Basique	Seconde année::Informatique::Logique	Nombre de valuations	Il y a exactement \(2^{|V|}\) valuations sur \(V\).
Basique	Seconde année::Informatique::Logique	Extension d'une valuation aux formules propositionnelles	On étend la définition d'une valuation \(\mu\) à \(\mathcal F_p(V)\) par: - \(\mu(\top) = 1; \mu(\bot) = 0\) - Pour \(x \in V, \mu(x) = \mu(x)\) (variable / formule) - Pour \(\varphi, \psi \in \mathcal F_p(V)\): * \(\mu(\neg \varphi) = 1 - \mu (\varphi)\) * \(\mu(\varphi \wedge\psi) = \min(\mu(\varphi), \mu(\psi))\) * \(\mu(\varphi \vee\psi) = \max(\mu(\varphi), \mu(\psi))\)  * \(\mu(\varphi \Rightarrow \psi) = \max(1 - \mu(\varphi), \mu(\psi))\)
Basique	Seconde année::Informatique::Logique	Modèle, ensemble des modèles	Un modèle de \(\varphi \in \mathcal F_p(V)\) est une valuation telle que \(\mu(\varphi) = 1\). On note \(\mathcal M(\varphi)\) l'ensemble des modèles de \(\varphi\).
Basique	Seconde année::Informatique::Logique	Modèles des opérateurs	Soient \(\varphi, \psi \in \mathcal F_p(V)\); - \(\mathcal M(\neg \varphi) = \overline{\mathcal M(\varphi)}\) - \(\mathcal M(\varphi \wedge \psi) = \mathcal M(\varphi) \cap \mathcal M(\psi)\) - \(\mathcal M(\varphi \vee \psi) = \mathcal M(\varphi) \cup \mathcal M(\psi)\) - \(\mathcal M(\varphi \Rightarrow \psi) = \overline{\mathcal M(\varphi)} \cup \mathcal M(\psi)\) - \(\mathcal M(\top) = \{0, 1\}^V\) - \(\mathcal M(\bot) = \varnothing\)
Basique	Seconde année::Informatique::Logique	Nombre de tables de vérité	Il existe \(2^{2^{|V|}}\) tables de vérité sur \(V\).
Basique	Seconde année::Informatique::Logique	Équivalence / Implication sémantiques	Pour \(\varphi, \psi \in \mathcal F_p(V)\) - \(\varphi\) est sémantiquement équivalente à \(\psi\), noté \(\varphi \equiv \psi\), ssi \(\mathcal M(\varphi) = \mathcal M(\psi)\) - \(\varphi\) implique sémantiquement \(\psi\), noté \(\varphi \models \psi\), ssi \(\mathcal M(\varphi) \subseteq \mathcal M(\psi)\)
Basique Maths	Seconde année::Informatique::Logique	Substitution (formule propositionnelle)	Soient \( \varphi,\psi \in \mathcal F_p(V) \) . On appelle substitution de \( x \) par \( \psi \) dans \( \varphi \) , \( \varphi[x := \psi] \) la formule \( \varphi \) où chaque occurrence de \( x \) est remplacée par \( \psi\).
Basique Maths	Seconde année::Informatique::Logique	Équivalence sémantique de substitutions	Soient \( \varphi, \psi,\sigma \in \mathcal F_p(V) \) telles que \( \varphi \equiv \psi \) . Soit \( x \in V \) . Alors:  \( \varphi[x := \sigma] \equiv \psi[x := \sigma]\)
Basique Maths	Seconde année::Informatique::Logique	Tautologie, antilogie, satisfaisabilité	Soit \( \varphi \in \mathcal F_p(V) \) . \( \varphi \) est: - satisfaisable si \( \mathcal M(\varphi) \ne \varnothing \)  - une tautologie si \( \mathcal M(\varphi) = \{0, 1\}^V \)  - une antilogie si \( \mathcal M(\varphi) = \varnothing\)
Basique Maths	Seconde année::Informatique::Logique	Caractérisation des tautologies	- \( \varphi \equiv \top \) ssi \( \top \models \varphi \) ssi \( \varphi \) est une tautologie - \( \varphi \equiv \psi \) ssi \( \varphi \Leftrightarrow \psi \) est une tautologie - \( \varphi \models \psi \) ssi \( \varphi \Rightarrow \psi\) est une tautologie
Basique Maths	Seconde année::Informatique::Logique	Réduction des formules sans \(\top,\bot\)	Toute \( \varphi \in \mathcal F_p(V) \) est \( \equiv \) à une formule de taille inférieure à \( |\varphi| \) qui est: * \( \top \)  * \( \bot \)  * une formule ne contenant ni \( \top \) ni \( \bot\)
Basique Maths	Seconde année::Informatique::Logique	Algorithme de Quine	- Simplifier \( \varphi \)  - si \( \varphi \ne \top \) et \( \varphi \ne \bot \) : * Soit \( x \) une variable dans \( \varphi \)  * Renvoyer \( N(\varphi, Quine(\varphi[x:=\bot]), Quine(\varphi[x:=\top])) \)  - sinon renvoyer \( \varphi\)
Basique Maths	Seconde année::Informatique::Logique	Satisfaisabilité / tautologie selon l'algorithme de Quine	- \( \varphi \) est satisfaisable ssi \( Quine(\varphi) \) contient des feuilles \( \top \)  - \( \varphi \) est une tautologie ssi \( Quine(\varphi) \) ne contient pas de feuilles \( \bot\)
Basique Maths	Seconde année::Informatique::Logique	Forme normale conjonctive / disjonctive	Forme normale conjonctive (FNC) : conjonction de disjonctions Forme normale disjonctive (FND) : Disjonction de conjonctions
Basique Maths	Seconde année::Informatique::Logique	Équivalence à une FNC / FND	Toute \( \varphi \in \mathcal F_p(V) \) est \( \equiv\) à une FNC et FND.
Basique Maths	Seconde année::Informatique::Logique	Segment	"On appelle segment un couple \( (\Gamma, \varphi) \) où \( \Gamma \subseteq \mathcal F_p(V), \varphi \in \mathcal F_p(V) \) . On note généralement \( \Gamma \vdash \varphi \) , "" \( \Gamma \) démontre \( \varphi\)"""
Basique Maths	Seconde année::Informatique::Logique	Règle d'inférence	On appelle règle d'inférence un couple formé de: - Un ensemble de séquents : prémisses - Un séquent : conclusion Une règle \( R \) se présente sous la forme:  \( \frac{\Gamma_1 \vdash \varphi_1 \dots \Gamma_n \vdash \varphi_n}{\Gamma \vdash \varphi}\)
Basique Maths	Seconde année::Informatique::Logique	Axiome	Un axiome est une règle sans prémisses: \( \overline{\Gamma \vdash \varphi}\)
Basique Maths	Seconde année::Informatique::Logique	Système déductif	Un système déductif est un ensemble de règles d'inférence
Basique Maths	Seconde année::Informatique::Logique	Preuve	Un preuve d'un séquent dans un système déductif est définie par induction: - Si \( \overline{\Gamma \vdash \varphi} \) est un axiome, \( \overline{\Gamma \vdash \varphi} \) est une preuve de \( \Gamma \vdash \varphi \) . - Si \( \frac{\Gamma_1 \vdash \varphi_1 \dots \Gamma_k \vdash \varphi_k}{\Gamma \vdash \varphi}R \) est une règle d'inférence et  \( P_1, \dots, P_k \) des preuves de \( \Gamma_1 \vdash \varphi_1, \dots, \Gamma_k \vdash \varphi_k \) , alors  \( \frac{P_1 \dots P_k}{\Gamma \vdash \varphi}R \) est une preuve de \( \Gamma \vdash \varphi\)
Basique Maths	Seconde année::Informatique::Logique	Systèmes équivalents, dérivabilité, théorèmes	- Deux systèmes déductifs sont équivalents si tout séquent prouvable dans l'un est prouvable dans l'autre - Une règle est dérivable si on peut prouver sa conclusion en admettant ses prémisses comme axiomes - on dit que \( \varphi \) est un théorème si \( \vdash \varphi\).
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Programme séquentiel / concurrent	Un programme est dit séquentiel si ses instructions sont exécutées l'une après l'autre, toujours dans le même ordre. Il est dit concurrent s'il est composé de plusieurs unités séquentielles, e.g. fil d'exécution (thread)
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Instruction atomique	Une instruction est dite atomique si elle est exécutée d'un seul bloc, sans interruption.
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Section critique	On appelle section critique une section du code qui lit ou écrit des données partagées par plusieurs fils.
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Exclusion mutuelle, absence de famine, équité, absence d'interblocage	- Exclusion mutuelle: deux fils ne peuvent pas se situer mutuellement en section critique - Absence de famine: chaque fil qui veut rentrer en section critique y parvient en un temps fini - Équité: chaque fil a la même probabilité d'entrer en section critique - Absence d'interblocage: si un ou plusieurs fils veulent entrer en section critique, l'un d'entre eux y parvient en temps fini
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Relation famine / interblocage	Absence de famine implique absence d'interblocage
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Mutex	Un mutex est un objet de synchronisation disposant de: - création - verrouillage - déverrouillage * Aucun fil ne peut terminer le verouillage d'un mutex verrouillé. * Seul le dernier fil qui l'a verrouillé peut déverrouiller le mutex.
Basique Maths	Seconde année::Informatique::Logique	Logique minimale	La logique minimale est constituée de quatre règles d'inférences: - Axiome : \( \frac{}{\Gamma, \varphi \vdash \varphi}ax \)  - Affaiblissement : \( \frac{\Gamma \vdash \varphi}{\Gamma, \psi \vdash \varphi}aff \)  - Implication; introduction :  \( \frac{\Gamma, \varphi \vdash \psi}{\Gamma\vdash \varphi \to \psi}\to_i \) , élimination : \( \frac{\Gamma\vdash \varphi \quad \Gamma \vdash\varphi \to \psi}{\Gamma\vdash \psi }\to_e\)
Basique Maths	Seconde année::Informatique::Logique	Littéral	Un littéral est une variable ou sa négation
Basique Maths	Seconde année::Informatique::Logique	Clause disjonctive / conjonctive	disjonction / conjonction de littéraux
Basique Maths	Seconde année::Informatique::Logique	Règles d'inférence, conjonction	Introduction : \( \frac{\Gamma \vdash \varphi \quad \Gamma \vdash \psi}{\Gamma \vdash \varphi \wedge \psi}\wedge_i \)  Élimination : \( \frac{\Gamma \vdash \varphi \wedge \psi}{\Gamma \vdash \varphi}\wedge^g_e \) , et \( \frac{\Gamma \vdash \varphi \wedge \psi}{\Gamma \vdash \psi}\wedge^d_e\)
Basique Maths	Seconde année::Informatique::Logique	Règles d'inférence, disjonction	Introduction : \( \frac{\Gamma \vdash \varphi}{\Gamma \vdash \varphi \wedge \psi}\wedge^g_i \) , et \( \frac{\Gamma \vdash \psi}{\Gamma \vdash \varphi \wedge \psi}\wedge^d_i \)  Élimination : \( \frac{\Gamma \vdash \varphi\vee\psi \quad \Gamma, \varphi \vdash \sigma \quad \Gamma, \psi \vdash \sigma}{\Gamma \vdash \sigma}\vee_e\)
Basique Maths	Seconde année::Informatique::Logique	Règles d'inférence, négation	Introduction : \( \frac{\Gamma, \varphi \vdash \bot}{\Gamma \vdash \neg \varphi}\neg_i \)  Élimination : \( \frac{\Gamma \vdash \varphi \quad \Gamma \vdash \neg \varphi}{\Gamma \vdash \bot}\neg_e\)
Basique Maths	Seconde année::Informatique::Logique	Règle d'introduction du vrai	 \( \frac{}{\Gamma \vdash \top}\top_i\)
Basique Maths	Seconde année::Informatique::Logique	Logique intuitionniste	La logique intuitionniste correspond à la logique minimale à laquelle on rajoute le principe d'explosion / principe d'élimination du faux: \( \frac{\Gamma \vdash \bot}{\Gamma \vdash \varphi}\bot_e\)
Basique Maths	Seconde année::Informatique::Logique	Logique classique	La logique classique correspond à la logique minimale à laquelle on rajoute le raisonnement par l'absurde: \( \frac{\Gamma, \neg \varphi \vdash \bot}{\Gamma \vdash \varphi}raa\)
Basique Maths	Seconde année::Informatique::Logique	Système déductif correct, complet, consistant / cohérent	Un système déductif est: - Correct si \( \Gamma \vdash \varphi \) implique \( \Gamma \models \varphi \)  - Complet si \( \Gamma \models \varphi \) implique \( \Gamma \vdash \varphi \)  - Consistant ou cohérent si \( \not\vdash \bot \) , i.e. \( \bot\) n'est pas un théorème.
Basique Maths	Seconde année::Informatique::Logique	Propriétés de la logique classique	La logique classique est correcte, cohérente et complète (dernier point HP).
Basique Maths	Seconde année::Informatique::Logique	Langage du premier ordre	Un langage du premier ordre est une famille de symboles: - de fonctions, \( S_f \)  - de relations, \( S_r\) À chaque symbole est associé une arité; une fonction d'arité 0 est une constante, une relation d'arité 0 est une variable propositionnelle.
Basique Maths	Seconde année::Informatique::Logique	Terme, terme clos	Avec \( \chi \) un ensemble infini dénombrable de variables et \( S_f \) un ensemble de fonctions d'arité quelconques. L'ensemble des termes est défini par induction par: - \( x \in \chi \) est un terme - Pour \( C\in S_F \) constante, \( C \) est un terme - Pour \( f \in S_F \) d'arité \( n > 0 \) et \( t_1, \dots, t_n \) des termes, \( f(t_1, \dots, t_n)\) est un terme. Un terme sans variable est clos.
Basique Maths	Seconde année::Informatique::Logique	Formule de la logique du premier ordre	Avec \( \mathcal L \) un langage du premier ordre, l'ensemble des formules de la logique du premier ordre est défini par induction par: - une formule atomique, de la forme \( R(t_1, \dots, t_n) \) , avec \( R \in \mathcal R \) une relation d'arité \( n \) et \( t_1, \dots, t_n \) des termes est une formule de la logique du premier ordre. - Si \( \varphi \) , \( \psi \) sont des formules de la logique du premier ordre, \( \neg \varphi, \varphi \wedge \psi, \varphi \vee \psi, \varphi \to \psi, \forall x \varphi, \exists x \varphi\) le sont aussi.
Basique Maths	Seconde année::Informatique::Logique	Occurence, liée / locale	Une occurence de \( x \) dans \( \varphi \) est une feuille \( x \) dans l'arbre syntaxique de \( \varphi \) . Une occurence est liée (ou locale) sur cette feuille possède un ancêtre \( \forall x \) ou \( \exists x\). Elle est dite libre ou globale sinon.
Basique Maths	Seconde année::Informatique::Logique	Variable libre dans une formule, formule close	Une variable est libre dans une formule si elle possède une occurence libre dans \( \varphi\). Une formule sans variable libre est dite close.
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Algorithme de Peterson	L'algorithme de Peterson pour le mutex est le suivant: - Créer : renvoyer {attente : [faux, faux], tour = 0} - Déverouiller:  * m.tour <- 1 - t  * m.attente[t] <- faux - Verouiller:  * m.attente[t] = vrai  * m.tour <- 1 - t  * Tant que m.tour != t et m.attente[1-t] : attendre
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Correction de l'algorithme de Peterson	L'algorithme de peterson respecte l'exclusion mutuelles, l'absence d'interblocage et l'absence de famine
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Algorithme de la boulangerie de Lamport	Mutex en deux tableaux : un indique qui attend, l'autre la priorité - Déverouiller:  * m.attente[t] <- faux - Verouiller:  * m.attente[t] <- vrai  * m.ticket[t] <- max(m.ticket) + 1  * Tant qu'il existe t' tel que (m.ticket[t'], t') < (m.ticket[t], t) et m.attente[t] : attendre
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Correction de la boulangerie de Lamport	L'algorithme de la boulangerie de Lamport satisfait l'exclusion mutuelle, l'absence d'interblocage et l'absence de famine.
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Sémaphore	Un sémaphore est un outil de synchronisation permettant: - initialisation à une valeur donnée - incrémenter - décrémenter
Basique Maths	Seconde année::Informatique::Concurrence et synchronisation	Compteur d'un sémaphore et fils en attente	Si le compteur d'un sémaphore est négatif, sa valeur absolue est le nombre de fils en attente.
Basique Maths	Seconde année::Informatique::Apprentissage	Terminaison des\(k\)-moyennes	L'algorithme des \( k\)-moyennes termine.
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Problème de décision	"On appelle problème de décision la donnée d'une instance et d'une question dichotomique: - Instance : Un objet possédant certaines caractéristiques - Question : Une question à laquelle on ne peut répondre que ""oui"" ou ""non"" On appelle instance positive (resp. négative) une instance pour laquelle la réponse à la question est ""oui"" (resp. ""non"")"
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Problème d'optimisation	On appelle problème d'optimisation la donnée d'une instance, d'une description de la solution et d'une mesure à optimiser: - Instance : un objet possédant certaines caractéristiques - Solution : La structure de la solution cherchée avec des conditions éventuelles - Optimisation : étant données une instance \( x \) et une solution \( y \) , la mesure est une fonction \( f(x,y) \) (en général à valeur dans \( \N \) ou \( \R \) ) qu'on cherche à maximiser ou minimiser selon \( y\).
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Taille d'une instance	Pour un problème donné (de décision ou d'optimisation), on définit la taille de l'instance comme l'espace mémoire nécéssaire pour représenter l'instance. Comme la taille intervient dans les calculs de complexité, on ne s'intéresse généralement qu'à un ordre de grandeur, donc l'unité n'a pas d'importance.
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Décidabilité	Un problème de décision est dit décidable s'il existe un algorithme/programme/fonction dans le modèle de calcul choisi permettant de le résoudre, c'est-à-dire un algorithme qui termine toujours en temps fini et répond correctement à la question posée. Il est dit indécidable sinon.
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Décidabilité du problème de l'arrêt	Le problème ARRÊT est indécidable.
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Semi-décidabilité (H.P.)	"On dit qu'un problème de décision est semi-décidable s'il existe un algorithme qui résoud correctement le problème pour toutes les instances positives (celles dont la réponse est ""oui"")."
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Semi-décidabilité du problème de l'arrêt	Le problème ARRÊT est semi-décidable.
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Réduction	On dit qu'un problème de décision \( A \) se réduit à un problème de décision \( B \) , noté \( A \le B \) , si la résolution du problème \( B \) peut permettre celle du problème \( A \) . On parle de réduction many-one si la résolution d'une seule instance de \( B \) permet de résoudre une instance de \( A \) . On note \( A \le_m B \) . On parle On parle de réduction Turing si la résolution d'une ou plusieurs instances de \( B \) permet de résoudre une instance de \( A \) . On note \( A \le_T B\).
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Réduction et décidabilité	Soient \( A \) et \( B \) deux problèmes de décision tels que \( A\le B \) . Alors: - si \( A \) est indécidable, alors \( B \) aussi; - si \( B \) est décidable, alors \( A\)aussi.
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Problème de l'arrêt	Le problème de l'arrêt est défini de la manière suivante: ARRÊT: - Instance : une fonction \( f \) et un argument \( x \)  - Question : est-ce que l'exécution de \( f(x)\)termine en temps fini?
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Problème de l'arrêt (vide)	Le problème de l'arrêt vide est défini de la manière suivante: ARRÊT (vide): - Instance : une fonction \( f \)  - Question : est-ce que l'exécution de \( f\)sans argumenttermine en temps fini?
Basique Maths	Seconde année::Informatique::Problèmes et décidabilité	Décidabilité de l'arrêt vide	La problème ARRÊT (vide) est indécidable.
Basique Maths	Seconde année::Informatique::Théorie des jeux	Jeu	Un jeu est un quadruplet \( (G, s_0, T_1, T_2) \) où: - \( G = (S,A) \) est un graphe orienté biparti, i.e. \( G = (S_1\sqcup S_2, A) \) , où \( A \subset S_1 \times S_2 \cup S_2 \times S_1 \)   \( S_1 \) : états du joueur 1  \( S_2 \) : états du joueur 2  \( G \) : arène - \( s_0 \in S \) : état de départ (unique source de \( G \) ) - Puits : états terminaux, dont:  \( T_1 \) : états gagnants pour 1  \( T_2 \) : états gagnants pour 2 Autres états : états nuls  \( (s,t) \in A \) signifie que depuis l'état du jeu \( s \) , on peut jouer un coup qui emmène en \( t\). On ne considère que des graphes sans cycles.
Basique Maths	Seconde année::Informatique::Théorie des jeux	Partie	une partie est un chemin de \( s_0\)à un sommet terminal.
Basique Maths	Seconde année::Informatique::Théorie des jeux	Stratégie	Une stratégie \( f \) pour le joueur \( i \) est une fonction \( f : S_i \to S_{3 - i} \) telle que \( \forall s \in S_i, (s, f(s)) \in A\)
Basique Maths	Seconde année::Informatique::Théorie des jeux	Position gagnante	Un sommet \( s \in S \) est appeléposition gagnante pour le joueur \( i \) s'il existe une stratégie gagnante pour \( i \) dans le jeu \( (G,s)\).
Basique Maths	Seconde année::Informatique::Théorie des jeux	Attracteur	L'ensemble des positions gagnantes pour \( i \) est appelé attracteur pour \( i\).
Basique Maths	Seconde année::Informatique::Théorie des jeux	Calcul des attracteurs	On définit par induction \( A_n(i) \) pour \( i \in \{1, 2\} \) par: - \( A_0(i) = T_i \)  - Pour \( n \in \N \) , \( A_{n + 1} (i) = A_n(i) \cup \{s \in S_i | \exists t \in A_n(i), (s,t) \in A\} \cup \{s \in S_{3-1} | \forall (s,t) \in A, t \in A_n(i)\} \)   \( A_n(i) \) converge alors vers un ensemble \( A(i) \) qui est l'attracteur du joueur \( i\).
Basique Maths	Seconde année::Informatique::Théorie des jeux	Construction d'une stratégie optimale	On construit une stratégie optimale \( f \) pour le joueur \( i \) en distinguant selon \( s \in S_i \) : - si \( s \in A(i) \) , il existe \( t \in A(i) \) tel que \( (s,t) \in A \) . On pose \( f(s) = t \) avec \( t \) un tel sommet. - si \( s \in A(3 - i) \) , on choisit \( t \) arbitrairement tel que \( (s,t) \in A \) . - sinon, on choisit \( t \in S\setminus(A(i) \cup A(3-i)) \) tel que \( (s,t) \in A \) et \( f(s) = t\).
Basique Maths	Seconde année::Informatique::Théorie des jeux	Condition pour que la stratégie optimale soit gagnante	Une stratégie optimale pour \( i \) est gagnante pour \( i \) si \( s_0 \in A(i)\).
Basique Maths	Seconde année::Informatique::Théorie des jeux	Heuristique	Une heuristique est une fonction qui donne une approximation d'une situation et qui est facile à calculer.
Basique Maths	Seconde année::Informatique::Théorie des jeux	Algorithme min-max	On attribue un score à chaque état du graphe des configurations: - \( 1 \) pour une position gagnante pour le joueur 1 - \( -1 \) pour une position gagnante pour le joueur 2 - \( 0 \) pour une position nulle On peut alors calculer récursivement le score d'un état: - Si \( s \) est final, renvoyer \( 1, -1, 0 \) selon que \( s \) est nul, ou gagnant pour 1 ou 2 - Si \( s \in S_1 \) , renvoyer le maximum des scores des voisins de \( s \)  - Si \( s \in S_2 \) , renvoyer le minimumdes scores des voisins de \( s\)
Basique Maths	Seconde année::Informatique::Théorie des jeux	Stratégie par min-max	À partir d'un état \( s \) , - On choisit une profondeur d'exploration \( p \)  - On considère le sous-graphe des sommets à distance au plus \( p \) de \( s \) . - On attribue un score à chaque sommet \( t \) de ce graphe selon le principe du min-max: * si \( t \) est un puits de ce sous-graphe, le score de \( t \) est donné par l'heuristique * sinon, si \( t \in S_1 \) , le score de \( t \) est le maximum des scores voisins de \( t \)  * sinon, si \( t \in S_2 \) , le score de \( t \) est le minimum des scores voisins de \( t \)  - On choisit comme coup à jouer le voisin de \( s\)qui maximise le score.
Basique Maths	Seconde année::Informatique::Théorie des jeux	Idée de l'élagage Alpha-Beta	On garde en mémoire les bornes du score d'un noeud de l'arbre. Si le score d'un fils de ce noeud sort de ces bornes, on peut arrêter complètement l'exploration de ce fils, et couper les branches restantes de ce fils.
Basique Maths	Seconde année::Informatique::Classes de complexité	Relation\(P, NP, PSPACE, NPSPACE, EXP\)	 \( P \subseteq NP \subseteq PSPACE = NPSPACE \subseteq EXP \)
Basique Maths	Seconde année::Informatique::Classes de complexité	Problème\(QSAT\)et complétude	\( QSAT \) : - Instance : \( \varphi \) une formule booléenne quantifiée - Question : \( \varphi \) est-elle satisfiable est \( PSPACE\)-complet.
Basique Maths	Seconde année::Informatique::Classes de complexité	Branch and Bound	Pour un problème \( \Pi \) d'optimisation de la mesire \( f \) ; on suppose disposer - d'une heuristique d'évaluation \( h \) qui évalue une solution partielle, qui est admissible (i.e. optimiste) - d'une heuristique de branchement \( b \) qui pour une solution partielle renvoie la liste des manières de la continuer, dans un certain ordre Pour chaque solution \( \tilde y \) : - Si elle est finale, on met à jour la meilleure solution \( y_{min} \) si elle l'améliore et sa mesure \( f_{min} \)  - Sinon, si \( h(\tilde y) < f_{min} \) , on exécute récursivement sur chaque complétion dans \( b(\tilde y)\).
Basique Maths	Seconde année::Informatique::Langages algébriques	Clôture des langages algébriques par intersection ou complémentaire	L'ensemble des langages algébriques n'est pas clos par intersection ni par complémentaire.
Basique Maths	Seconde année::Informatique::Langages algébriques	Récursivité à gauche / droite	Soit \( G = (\Sigma, V, P, S) \) une CFG. \( G \) est récursive à gauche (resp. à droite) s'il existe \( X\in V \) et une suite non vide de dérivations immédiates \( X \Rightarrow^+X\alpha \) (resp. \( X \Rightarrow^+\alpha X\)).
Basique Maths	Seconde année::Informatique::Théorie des jeux	Stratégie gagnante	 \( f \) est gagnante pour \( i \) ssi pour toute stratégie \( g \) du joueur \( 3 - i \) , \( \exists n \in \N, (f \circ g)^n(s_0) \in T_i \text{ ou } g \circ (f \circ g)^n(s_0) \in T_i \text{ ou } f \circ (g \circ f)^n(s_0) \in T_i \text{ ou } (g \circ f)^n(s_0) \in T_i\)
Basique Maths	Seconde année::Informatique::Logique	Substitution dans une formule du premier ordre	Soit \( \varphi \) une formule du premier ordre, \( x \) une variable et \( t \) un terme. On appelle substitution de \( x \) par \( t \) dans \( \varphi \) , noté \( \varphi[x := t] \) la formule obtenue en: - renommant toutes les occurences liées dans \( \varphi \) de chaque variable \( y \) qui est libre dans \( t \)  - remplaçant toutes les occurences libres de \( x \) dans \( \varphi \) par \( t\).
Basique Maths	Seconde année::Informatique::Logique	Règles d'inférence, quantificateur existentiel	Introduction : \( \frac{\Gamma \vdash \varphi [x := t]}{\Gamma \vdash \exists x \varphi}\exists_i \)  Élimination : \( \frac{\Gamma \vdash \exists x \varphi \quad \Gamma, \varphi \vdash \psi \quad x \notin V_F(\Gamma) \cup V_F(\psi)}{\Gamma \vdash \psi}\exists _e\)
Basique Maths	Seconde année::Informatique::Logique	Règles d'inférence, quantificateur universel	Introduction : \( \frac{\Gamma \vdash \varphi \quad x \notin V_F(\Gamma)}{\Gamma \vdash \forall x \varphi}\forall_i \)  Élimination : \( \frac{\Gamma \vdash \forall x \varphi}{\Gamma \vdash \varphi[x :=t]}\forall_e\)
